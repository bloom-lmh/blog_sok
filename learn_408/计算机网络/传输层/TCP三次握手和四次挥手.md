# TCP 三次握手和四次挥手

[[toc]]

## 三次握手

连接建立前，服务器进程处于 LISTEN （收听）状态，等待客户的连接请求

| 步骤 | 发送方向        | 报文段名称         | 首部字段值                                                                                                                                                                   | 状态变化                              |
| ---- | --------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- |
| 1    | 客户端 → 服务端 | **连接请求报文段** | `SYN=1`（同步位，表示是否连接请求/同步报文，SYN 仅在建立连接的初始同步时置 1，后续报文（包括第三步）无需再同步）, `ACK=0`（表示不捎带数据）, `seq=x`（随机初始序号）, 无数据 | 客户端进入 `SYN-SENT`同步已发送状态   |
| 2    | 服务端 → 客户端 | **确认报文段**     | `SYN=1`, `ACK=1`, `seq=y`（服务端随机序号）, `ack=x+1`（确认客户端序号,前面的序号已经确定，期望下一个报文段的序号）                                                          | 服务端进入 `SYN-RCVD` 同步收到状态    |
| 3    | 客户端 → 服务端 | **确认报文段**     | `SYN=0`, `ACK=1`, `seq=x+1`, `ack=y+1`（确认服务端序号，期望服务端下一个报文段的序号）, 可携带数据                                                                           | 双方进入 `ESTABLISHED` 已建立连接状态 |

成功进行以上三步后，就建立了 TCP 连接，接下来就可以传送应用层数据。

![三次握手](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250716121503692.png)

::: tip 为什么要三次握手？而不是两次或四次？
因为 TCP 是全双工通信，客户端和服务端都能互相发送消息，并且 TCP 是可靠的传输协议，所以双方都需要互相发送确认信息，确保数据能到达对方。

1. A 说：“你能听到我吗？”（SYN）
2. B 回答：“我能听到你，你能听到我吗？”（SYN-ACK）
3. A 说：“我也能听到你。”（ACK）

可以看到服务端和客户端发送的报文段中都有 ack 字段，ack 字段的作用是用来确认上一个报文段的序号，并期望下一个报文段的序号。

:::

::: warning 资源分配时机与泛洪攻击
服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的。
当服务端收到客户端的 SYN（第一次握手）并回复 SYN+ACK（第二次握手）后，​ 立即分配连接资源 ​（如内核内存、连接队列条目）。
此时连接尚未完全建立（未收到客户端的 ACK），若客户端是恶意伪造的（不完成第三次握手），服务端资源会被长期占用，直到超时释放（典型超时为 30 秒~2 分钟）。

:::

## 四次挥手

![四次挥手](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250716145738894.png)

| **步骤** | **发送方向**    | **报文段名称** | **首部字段值**                                                                                                     | **状态变化**                                                                     | **资源释放时机**                      |
| -------- | --------------- | -------------- | ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- | ------------------------------------- |
| **1**    | 客户端 → 服务端 | 连接释放报文段 | `FIN=1`（终止请求），`seq=u`（最后字节数据序号+1）                                                                 | 客户端进入 `FIN-WAIT-1` （终止等待 1）状态                                       | **客户端关闭发送通道**                |
| **2**    | 服务端 → 客户端 | 确认报文段     | `ACK=1`，`ack=u+1`，`seq=v`（服务端发送的最后数据序号+1）                                                          | 服务端进入 `CLOSE-WAIT` （关闭等待）状态，客户端进入 FIN-WAIT2（终止等待 2）状态 | **服务端释放客户端 → 服务端方向资源** |
| **3**    | 服务端 → 客户端 | 连接释放报文段 | `FIN=1`，`ACK=1`，`seq=w`（半关闭后新数据序号，因为单项关闭后服务端还可以向客户端发送数据），`ack=u+1`（重复确认） | 服务端进入 `LAST-ACK`（最后确认）                                                | **服务端准备完全关闭连接**            |
| **4**    | 客户端 → 服务端 | 确认报文段     | `ACK=1`，`ack=w+1`，`seq=u+1`                                                                                      | 客户端进入 `TIME-WAIT`（等待 2MSL 后关闭） ，服务端处于 CLOSED(连接关闭)状态     | **客户端最终释放连接**                |
