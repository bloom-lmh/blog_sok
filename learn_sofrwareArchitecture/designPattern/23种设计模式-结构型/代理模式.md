# 代理模式

[[toc]]

## 概念

定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式是结构型模式
动机：代理对象可以在客户端和目标对象之间起到中介的作用，通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外的新服务

## 结构

![类图](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250711182526211.png)

- Subject: 抽象主题角色，定义真实对象和代理对象的共同行为。
- Proxy: 代理主题角色，持有 RealSubject 的引用，控制对其的访问。
- RealSubject: 真实主题角色，实现核心业务逻辑（如数据库查询、文件读写）。

## 实现

JS 中有默认的代理对象

```js
// 真实对象
const realUser = {
  name: 'Alice',
  password: 'secret123',
  isAdmin: false,
};

// 代理对象
const userProxy = new Proxy(realUser, {
  get(target, prop) {
    if (prop === 'password') {
      throw new Error('无权访问密码！');
    }
    return target[prop];
  },
  set(target, prop, value) {
    if (prop === 'isAdmin') {
      throw new Error('无权修改管理员权限！');
    }
    target[prop] = value;
    return true;
  },
});

// 测试
console.log(userProxy.name); // "Alice"
console.log(userProxy.password); // Error: 无权访问密码！
userProxy.isAdmin = true; // Error: 无权修改管理员权限！
```

- 真实主题角色：realUser
- 抽象主题角色：
  - 在传统模式中，这是一个显式接口。
  - 在 JavaScript 中，由对象的预期行为隐式定义（如 realUser 应该有 name 和 password 属性）。
- 代理主题角色：Proxy

## 特点

优点：

- 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
- 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性
- 远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率
- 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销
- 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间
- 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限

缺点：

- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理）
- 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）

适用场景：

- 当客户端对象需要访问远程主机中的对象时可以使用远程代理
- 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理
- 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理
- 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理
- 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理
