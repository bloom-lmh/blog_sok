# 适配器模式

[[toc]]

## 定义

适配器模式（Adapter Pattern）是一种结构型设计模式，它使得原本由于接口不兼容而不能一起工作的两个类可以一起工作。这种模式涉及到一个单独的类，该类负责加入新的接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。
::: tip 理解
其实就是面向老接口（不兼容的接口）提供新的兼容的接口，这里强调新接口类对旧接口的组合关系,适配器也叫包装器模式
:::

## 结构

![适配器类图](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250819202301805.png)

- `Target`：目标接口，定义客户端所需的方法。
- `Adaptee`：源接口，定义需要适配的接口。
- `Adapter`：适配器类，实现了目标接口，并持有源接口的实例，在适配器的方法中，可以调用源接口的方法，从而使得原本由于接口不兼容而不能一起工作的类可以一起工作。

## 实现

需求：比如有百度地图和腾讯地图，他们渲染地图调用不同的接口，现在新系统希望同时接入这两个地图，但是由于接口不兼容，不能直接调用。所以这里可以使用适配器，将两个接口统一为一个相同的接口，这样就可以调用了

### 对象适配器模式

通过组合持有被适配者（Adaptee）的实例，并实现目标接口（Target）。
::: code-group

```js [源接口]
class TencentMap {
  showMap() {
    console.log('show tencent map');
  }
}
class BaiduMap {
  disPlayMap() {
    console.log('show baidu map');
  }
}
```

```js [目标接口]
function mapSystem(map: MapAdapter) {
  map.render(map);
}
interface MapAdapter {
  render(mapAdapter: any): void;
}
```

```js [源接口适配器]
class BaiduMapAdapter implements MapSystem {
  adapee: BaiduMap;
  constructor(adapee: BaiduMap) {
    this.adapee = adapee;
  }
  render(mapAdapter: any): void {
    this.adapee.disPlayMap();
  }
}
```

```js [客户端]
mapSystem(new TencentMapAdapter(new TencentMap()));
mapSystem(new BaiduMapAdapter(new BaiduMap()));
```

:::

### 类适配器模式

通过继承被适配者（Adaptee）并实现目标接口（Target）

改造后的类适配器模式实现
:::code-group

```js [源接口]
typescript[目标接口];
// 目标接口（统一的地图渲染规范）
interface MapAdapter {
  render(): void;
}
```

```typescript [源接口（被适配者）]
// 被适配者：腾讯地图
class TencentMap {
  showMap() {
    console.log('腾讯地图展示');
  }
}

// 被适配者：百度地图
class BaiduMap {
  disPlayMap() {
    console.log('百度地图展示');
  }
}
```

```typescript [类适配器]
// 腾讯地图的类适配器（通过继承）
class TencentMapAdapter extends TencentMap implements MapAdapter {
  render() {
    this.showMap(); // 直接调用父类方法
  }
}

// 百度地图的类适配器（通过继承）
class BaiduMapAdapter extends BaiduMap implements MapAdapter {
  render() {
    this.disPlayMap(); // 直接调用父类方法
  }
}
```

```typescript [客户端调用]
function mapSystem(map: MapAdapter) {
  map.render(); // 统一调用目标接口
}

// 使用类适配器
mapSystem(new TencentMapAdapter()); // 输出: "腾讯地图展示"
mapSystem(new BaiduMapAdapter()); // 输出: "百度地图展示"
```

:::

## 实际应用场景

比如 `axios` 库，在 node 端使用`http`发 `get` 请求和在浏览器使用 `XMLHttpRequest` 发送 `get` 的方式和接口是不一样的
如何让在浏览器端和 node 端都能使用统一的接口发送 `get` 请求呢？这就需要使用适配器模式。

::: code-group

```js [node 发送 get 请求]
const http = require('http');
const https = require('https');

function nodeGet(url, callback) {
  const client = url.startsWith('https') ? https : http;
  const req = client.get(url, res => {
    let data = '';
    res.on('data', chunk => (data += chunk));
    res.on('end', () => {
      callback(null, {
        data: JSON.parse(data),
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: { url },
      });
    });
  });

  req.on('error', err => {
    callback(err);
  });
}
```

```js
// 浏览器原生方式
function browserGet(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.responseType = 'json';

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if (xhr.status >= 200 && xhr.status < 300) {
        callback(null, {
          data: xhr.response,
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders()),
          config: { url },
        });
      } else {
        callback(new Error(xhr.statusText));
      }
    }
  };

  xhr.send();
}

// 辅助函数：解析响应头
function parseHeaders(headerStr) {
  const headers = {};
  if (!headerStr) return headers;
  headerStr.split('\r\n').forEach(line => {
    const [key, value] = line.split(': ');
    if (key) headers[key.toLowerCase()] = value;
  });
  return headers;
}
```

```js
// myAxios - 简化版适配器模式实现
const myAxios = {
  // 核心方法
  get(url) {
    return this._request({ method: 'get', url });
  },

  // 统一请求入口
  async _request(config) {
    // 1. 获取适配器（根据环境自动选择）
    const adapter = this.defaults.adapter || this.getDefaultAdapter();

    // 2. 调用适配器发送请求
    const response = await adapter(config);
    return response;
  },

  // 默认适配器选择逻辑
  getDefaultAdapter() {
    if (typeof process !== 'undefined' && process.toString() === '[object process]') {
      // Node.js 环境
      return this.nodeAdapter;
    } else {
      // 浏览器环境
      return this.browserAdapter;
    }
  },

  // Node.js 适配器
  nodeAdapter(config) {
    return new Promise((resolve, reject) => {
      const { url } = config;
      const client = url.startsWith('https') ? require('https') : require('http');

      const req = client.get(url, res => {
        let data = '';
        res.on('data', chunk => (data += chunk));
        res.on('end', () => {
          try {
            const jsonData = data ? JSON.parse(data) : {};
            resolve({
              data: jsonData,
              status: res.statusCode,
              statusText: res.statusMessage,
              headers: res.headers,
              config,
            });
          } catch (e) {
            reject(e);
          }
        });
      });

      req.on('error', reject);
    });
  },

  // 浏览器适配器
  browserAdapter(config) {
    return new Promise((resolve, reject) => {
      const { url } = config;
      const xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.responseType = 'json';

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve({
              data: xhr.response,
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders()),
              config,
              request: xhr,
            });
          } else {
            reject(new Error(xhr.statusText));
          }
        }
      };

      xhr.send();
    });
  },

  // 默认配置
  defaults: {
    adapter: null, // 可以手动设置
  },
};

// 导出（或挂载到 window）
if (typeof module !== 'undefined') {
  module.exports = myAxios;
}
```

::::

## 优缺点

优点

- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构
- 增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用
- 灵活性和扩展性非常好
- 类适配器模式：置换一些适配者的方法很方便
- 对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类

缺点

类适配器模式：

- 一次最多只能适配一个适配者类，不能同时适配多个适配者
- 适配者类不能为最终类
- 目标抽象类只能为接口，不能为类

对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦
