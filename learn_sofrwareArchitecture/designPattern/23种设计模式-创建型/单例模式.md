# 单例模式

[[toc]]

## 定义

保证一个类仅有一个实例，并提供一个访问它的全局访问点，主要解决一个全局使用的类频繁创建与销毁所带来的性能问题。

::: tip 并发问题
因为 JavaScript 是单线程语言，不存在多线程并发访问的问题
:::

## 结构

## 实现

### 闭包实现方式

```js
let Singleton = (function () {
  let instance;

  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  return function (name, age) {
    if (!instance) {
      instance = new User(name, age);
    }
    return instance;
  };
})();
```

### 类实现方式

```js
class Singleton {
  constructor(name, age) {
    if (!Singleton.instance) {
      this.name = name;
      this.age = age;
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}
```

## 案例

全局模态框使用单例模式

```js
// 单例模式模态框实现
const Modal = (function () {
  let instance = null;

  function createModal() {
    const modal = document.createElement('div');
    modal.innerHTML = '登录对话框';
    modal.className = 'kerwin-modal';
    modal.style.display = 'none';
    document.body.appendChild(modal);
    return modal;
  }

  return function () {
    if (!instance) {
      instance = createModal();
    }
    return instance;
  };
})();

// 事件绑定
document.querySelector('#open').onclick = function () {
  const modal = Modal();
  modal.style.display = 'block';
};

document.querySelector('#close').onclick = function () {
  const modal = Modal();
  modal.style.display = 'none';
};
```

## 扩展

对于多线程环境，需要考虑线程安全问题。

### 懒汉式

- 延迟加载：只有第一次调用 getInstance() 时才创建实例。
- 节省资源：如果单例对象很大或初始化耗时，懒汉式可以避免不必要的开销。
- 线程不安全：需要额外处理线程安全 ​（在 Java/C++ 等多线程语言中）。

::: code-group

```java [java实现]
// 在 Java 中，懒汉式需要加锁（synchronized）或使用双重检查锁定（DCL）来保证线程安全：
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

```js [js实现]
// 由于 JS 是单线程的，所以不需要额外加锁，直接判断 instance 是否存在即可：
class Singleton {
  static instance = null;

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }

  constructor() {
    if (Singleton.instance) {
      throw new Error('Use Singleton.getInstance() instead of new');
    }
  }
}

// 使用
const s1 = Singleton.getInstance();
const s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

:::

### 饿汉式

- 提前初始化:类加载时就创建实例，避免多线程问题。
- 线程安全:因为实例在类加载时就创建了，不存在并发问题。
- 可能浪费资源:如果单例对象很大或初始化耗时，但从未使用，会造成资源浪费。

::: code-group

```js [js实现]
class Singleton {
  static instance = new Singleton(); // 类加载时就初始化

  static getInstance() {
    return Singleton.instance;
  }

  constructor() {
    if (Singleton.instance) {
      throw new Error('Use Singleton.getInstance() instead of new');
    }
  }
}

// 使用
const s1 = Singleton.getInstance();
const s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

```java [java实现]
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

:::

## 总结
