# 工厂方法模式

[[toc]]

## 概述

工厂方法模式（Factory Method Pattern）又称工厂模式，也叫做虚拟构造器（Virtual Constructor）模式或多态工厂模式（Polymorphic Factory Pattern）,它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。**这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪个具体产品类**。

::: tip 简单理解
比如我们的产品是车，车工厂负责生产车，定义好生产车的接口。但是具体是生产哪类车（比如轿车、SUV、轿跑车等）则是由子类决定，轿车工厂生产轿车，SUV 工厂生产 SUV，轿跑车工厂生产轿跑车等。这样就解决了简单工厂模式中，如果要增加新的产品就要修改工厂类，违背开闭原则的问题。我们增加一个同类产品只需要增加一个对应工厂即可
:::

## 结构

| 角色                           | 类型        | 职责                           | 关键特征                            |
| ------------------------------ | ----------- | ------------------------------ | ----------------------------------- |
| **抽象产品** (Product)         | 接口/抽象类 | 定义产品的通用接口             | 声明所有产品共有的方法（如`use()`） |
| **具体产品** (ConcreteProduct) | 具体类      | 实现抽象产品的具体功能         | 工厂方法实际创建的对象              |
| **抽象工厂** (Creator)         | 抽象类      | 声明工厂方法（可能含默认逻辑） | 包含`factoryMethod()`抽象方法       |
| **具体工厂** (ConcreteCreator) | 具体类      | 实现工厂方法                   | 决定实例化哪个具体产品              |

## 案例

::: code-group

```js [抽象产品]
// 要生产的产品就是车
class Car {
  start() {
    throw new Error('抽象方法必须被实现');
  }

  accelerate() {
    throw new Error('抽象方法必须被实现');
  }
}
```

```js [具体产品]
// 轿车具体的车
class Sedan extends Car {
  start() {
    console.log('轿车启动：安静平稳');
  }

  accelerate() {
    console.log('轿车加速：0-100km/h 8秒');
  }
}
// SUV具体的车
class SUV extends Car {
  start() {
    console.log('SUV启动：动力强劲');
  }

  accelerate() {
    console.log('SUV加速：0-100km/h 10秒');
  }
}
```

```js [抽象工厂接口]
// car工厂接口，定义了生产车的方法
class CarFactory {
  createCar() {
    throw new Error('抽象方法必须被实现');
  }
}
```

```js [实现具体工厂]
// 每个车型对应一个工厂
class SedanFactory extends CarFactory {
  createCar() {
    console.log('生产一辆新轿车,细节与生产SUV不同');
    return new Sedan();
  }
}

class SUVFactory extends CarFactory {
  createCar() {
    console.log('生产一辆新SUV，细节与Sewan不同');
    return new SUV();
  }
}
```

```js [客户端使用示例]
// 生产不同车型
console.log('=== 轿车试驾 ===');
new SedanFactory().createCar().start();

console.log('\n=== SUV试驾 ===');
new SUVFactory().createCar().start();

console.log('\n=== 轿跑车试驾 ===');
new SedanFactory().createCar().accelerate();
```

:::

## 总结

| **分类**     | **优点**                                                                            | **缺点**                                                                 |
| ------------ | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **扩展性**   | ✅ 符合开闭原则，新增产品只需添加新工厂类，无需修改已有代码                         | ❌ 每新增一个产品就需要增加一个工厂类，导致类数量膨胀                    |
| **耦合度**   | ✅ 解耦客户端与具体产品，客户端仅依赖抽象接口                                       | ❌ 客户端仍需知道具体工厂类（如 `new SedanFactory()`）                   |
| **职责分离** | ✅ 单一职责原则，每个工厂只负责创建一种产品                                         | ❌ 简单对象创建场景可能过度设计，增加不必要的复杂度                      |
| **多态性**   | ✅ 支持运行时动态决定对象类型，便于实现多态行为                                     | ❌ 需要预先设计抽象层次，对新手理解成本较高                              |
| **维护性**   | ✅ 各产品线可独立演化，修改一个工厂不影响其他产品                                   | ❌ 需要维护工厂和产品的双重类结构，长期可能增加维护负担                  |
| **测试性**   | ✅ 便于单元测试，可通过 Mock 工厂注入测试对象                                       | ❌ 因抽象层级增加，调试时需要追踪更多调用链                              |
| **性能**     | -                                                                                   | ❌ 轻微性能开销（多一层方法调用），但对现代 JS 引擎影响极小              |
| **适用场景** | 🔹 需要灵活扩展产品类型<br>🔹 跨平台/多环境实现<br>🔹 框架设计（如 React 组件创建） | 🔸 产品类型稳定不变<br>🔸 创建逻辑非常简单<br>🔸 对内存/类数量敏感的场景 |
