# 职责链模式

[[toc]]

## 概念

避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止

::: tip 职责链还可以实现后处理
![](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250708221206339.png)
:::

## 结构

![类图](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250708214625716.png)

- Handler: 抽象处理者，定义处理请求的接口
- ConcreteHandler: 具体处理者，实现抽象处理者的接口，处理请求，并向下传递请求

## 实现

模拟 `servlet filter` 版

::: code-group

```java [上下文对象]
// Request.java
public class Request {
    private String data;

    public Request(String data) {
        this.data = data;
    }

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "Request{" + "data='" + data + '\'' + '}';
    }
}

// Response.java
public class Response {
    private String result;

    public String getResult() {
        return result;
    }

    public void setResult(String result) {
        this.result = result;
    }

    @Override
    public String toString() {
        return "Response{" + "result='" + result + '\'' + '}';
    }
}
```

```java [抽象处理者] {8-17}
// Filter.java
public interface Filter {
    void doFilter(Request request, Response response, FilterChain chain);
}
```

```java [过滤器链]
// FilterChain.java
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;

public class FilterChain {
    private List<Filter> filters = new ArrayList<>();
    private Iterator<Filter> iterator;
    private int index = 0;

    // 添加过滤器
    public FilterChain addFilter(Filter filter) {
        this.filters.add(filter);
        return this;
    }

    // 开始执行过滤器链
    public void doFilter(Request request, Response response) {
        // 如果还有过滤器，执行下一个
        if (index < filters.size()) {
            Filter filter = filters.get(index);
            index++;
            filter.doFilter(request, response, this); // 传递 this 作为 chain
        } else {
            // 所有过滤器执行完毕，执行目标处理逻辑
            handleRequest(request, response);
        }
    }

    // 模拟最终的目标处理（如 Servlet 的 service 方法）
    private void handleRequest(Request request, Response response) {
        System.out.println("[Target Handler] 处理请求: " + request);
        response.setResult("处理完成: " + request.getData().toUpperCase());
    }
}
```

```java [具体处理者]
// LoggingFilter.java
public class LoggingFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain chain) {
        System.out.println("[LoggingFilter] 开始处理: " + request);
        chain.doFilter(request, response); // 继续下一个
        System.out.println("[LoggingFilter] 结束处理，响应: " + response);
    }
}

// AuthFilter.java
public class AuthFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain chain) {
        System.out.println("[AuthFilter] 校验请求: " + request);
        if (request.getData().contains("admin")) {
            System.out.println("[AuthFilter] 权限校验通过");
            chain.doFilter(request, response);
        } else {
            System.out.println("[AuthFilter] 拒绝访问，无权限");
            response.setResult("403 禁止访问");
            // 不调用 chain.doFilter()，短路处理
        }
    }
}

// UpperCaseFilter.java
public class UpperCaseFilter implements Filter {
    @Override
    public void doFilter(Request request, Response response, FilterChain chain) {
        System.out.println("[UpperCaseFilter] 转换为大写前: " + request.getData());
        request.setData(request.getData().toUpperCase());
        chain.doFilter(request, response);
        // 可以在这里做后置处理
        System.out.println("[UpperCaseFilter] 响应处理完成");
    }
}
```

```java [客户端]
// Main.java
public class Main {
    public static void main(String[] args) {
        FilterChain chain = new FilterChain();
        chain.addFilter(new LoggingFilter())
             .addFilter(new AuthFilter())
             .addFilter(new UpperCaseFilter());

        // 测试1：有权限
        System.out.println("=== 测试1：包含 admin ===");
        Request req1 = new Request("admin:创建用户");
        Response resp1 = new Response();
        chain.doFilter(req1, resp1);
        System.out.println("最终响应: " + resp1);

        System.out.println("\n=== 测试2：不包含 admin ===");
        // 测试2：无权限
        Request req2 = new Request("guest:查看首页");
        Response resp2 = new Response();
        chain.doFilter(req2, resp2);
        System.out.println("最终响应: " + resp2);
    }
}
```

:::

## 总结

优点:

- 使得一个对象无须知道是其他哪一个对象处理其请求，降低了系统的耦合度
- 可简化对象之间的相互连接
- 给对象职责的分配带来更多的灵活性
- 增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可

缺点:

- 不能保证请求一定会被处理
- 对于比较长的职责链，系统性能将受到一定影响，在进行代码调试时不太方便
- 如果建链不当，可能会造成循环调用，将导致系统陷入死循环

适用场景:

- 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定
- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
- 可动态指定一组对象处理请求
