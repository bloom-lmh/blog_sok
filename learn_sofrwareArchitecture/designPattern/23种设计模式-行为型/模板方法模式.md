# 模板方法模式

[[toc]]

## 定义

父类规定算法流程，子类实现具体流程细节。同一套处理流程因为实现细节的不同而不同

::: tip 一句话理解
**工厂方法模式是模板方法的一种**或者说工厂方法是返回对象的模板方法。（两种可以贯通）

模板方法：父类定义流程，子类定义实现流程细节。
工厂方法：父类定义创建对象流程，子类实现流程细节。创建对象的地方是对象创建流程执行的地方
:::

## 结构

![类图](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250803184332118.png)

- AbstractClass（抽象类）：定义算法流程
- ConcreteClass（具体类）：实现算法流程

## 实现

需求：多个页面的行为是一样的

1. 获取数据
2. 渲染

使用模板方法模式来进行封装

### 函数实现

思路：传入一个实现对象 params 来替换默认的抽象模板方法。这样使用的时候就是具体的模板方法了。template 还是一个工厂

```js
const template = function (params) {
  // params传入的的是具体流程实现。替换原型的抽象方法
  let F = function () {};
  F.prototype.init = () => {
    this.getData();
    this.render();
  };
  F.prototype.getData =
    params.getData ||
    function () {
      throw new Error('Not implemented');
    };
  F.prototype.render = () => {
    console.log('Rendering');
  };
  // 返回函数，所以它既是工厂又是模板方法
  return F;
};

let t1 = template(() => {
  console.log('getData1');
});
let t2 = template({
  getData: () => {
    console.log('getData2');
  },
});
```

### 类实现

```ts
class Template {
  init() {
    this.getData();
    this.render();
  }
  getData() {
    throw new Error('Not implemented');
  }
  render() {}
}
class T1 extends Template {
  getData() {
    console.log('getData1');
  }
}
class T2 extends Template {
  getData() {
    console.log('getData2');
  }
}
```

## 总结
