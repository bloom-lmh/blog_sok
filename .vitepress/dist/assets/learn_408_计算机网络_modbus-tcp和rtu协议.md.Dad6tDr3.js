import{_ as o,c as r,o as s,ae as d}from"./chunks/framework.Dh1jimFm.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"learn_408/计算机网络/modbus-tcp和rtu协议.md","filePath":"learn_408/计算机网络/modbus-tcp和rtu协议.md"}'),n={name:"learn_408/计算机网络/modbus-tcp和rtu协议.md"};function l(a,t,e,i,g,u){return s(),r("div",null,t[0]||(t[0]=[d('<h3 id="modbus-tcp-和-modbus-rtu-的区别" tabindex="-1"><strong>Modbus-TCP 和 Modbus-RTU 的区别</strong> <a class="header-anchor" href="#modbus-tcp-和-modbus-rtu-的区别" aria-label="Permalink to &quot;**Modbus-TCP 和 Modbus-RTU 的区别**&quot;">​</a></h3><p>Modbus 是一种广泛应用于工业自动化领域的通信协议，主要有 <strong>Modbus-TCP</strong>（基于以太网）和 <strong>Modbus-RTU</strong>（基于串口，如 RS485）两种变体。它们的核心区别如下：</p><hr><h2 id="_1-物理层-通信方式" tabindex="-1"><strong>1. 物理层 &amp; 通信方式</strong> <a class="header-anchor" href="#_1-物理层-通信方式" aria-label="Permalink to &quot;**1. 物理层 &amp; 通信方式**&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>Modbus-TCP</strong></th><th><strong>Modbus-RTU</strong></th></tr></thead><tbody><tr><td><strong>物理接口</strong></td><td>以太网（TCP/IP）</td><td>RS485 / RS232</td></tr><tr><td><strong>传输方式</strong></td><td>基于 IP 网络（WiFi/以太网）</td><td>串行通信（点对点或多点）</td></tr><tr><td><strong>通信速率</strong></td><td>100 Mbps ~ 1 Gbps（取决于网络）</td><td>通常 9600 ~ 115200 bps</td></tr><tr><td><strong>最大设备数</strong></td><td>理论上无限制（受网络限制）</td><td>通常 32 ~ 247 个设备（RS485）</td></tr></tbody></table><hr><h2 id="_2-数据帧结构" tabindex="-1"><strong>2. 数据帧结构</strong> <a class="header-anchor" href="#_2-数据帧结构" aria-label="Permalink to &quot;**2. 数据帧结构**&quot;">​</a></h2><h3 id="_1-modbus-tcp" tabindex="-1"><strong>(1) Modbus-TCP</strong> <a class="header-anchor" href="#_1-modbus-tcp" aria-label="Permalink to &quot;**(1) Modbus-TCP**&quot;">​</a></h3><ul><li><strong>MBAP 头（7 字节） + PDU（协议数据单元）</strong><ul><li><strong>MBAP 头</strong>（Modbus Application Protocol Header）： <ul><li><strong>事务标识符（2 字节）</strong>：匹配请求和响应（类似 TCP 序列号）</li><li><strong>协议标识符（2 字节）</strong>：固定 <code>0x0000</code>（表示 Modbus）</li><li><strong>长度（2 字节）</strong>：后续数据的字节数</li><li><strong>单元标识符（1 字节）</strong>：类似 RTU 的从机地址（通常 <code>0x01</code>）</li></ul></li><li><strong>PDU</strong>（功能码 + 数据）： <ul><li>与 RTU 相同，但没有 CRC 校验（TCP 自带校验）</li></ul></li></ul></li></ul><p><strong>示例（读取寄存器 0x0000~0x0015）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>00 00 00 00 00 06 01 03 00 00 00 15</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><code>00 00</code>：事务 ID</li><li><code>00 00</code>：协议 ID</li><li><code>00 06</code>：后续数据长度（6 字节）</li><li><code>01</code>：单元 ID</li><li><code>03</code>：功能码（读寄存器）</li><li><code>00 00</code>：起始地址</li><li><code>00 15</code>：寄存器数量</li></ul><hr><h3 id="_2-modbus-rtu" tabindex="-1"><strong>(2) Modbus-RTU</strong> <a class="header-anchor" href="#_2-modbus-rtu" aria-label="Permalink to &quot;**(2) Modbus-RTU**&quot;">​</a></h3><ul><li><strong>从机地址（1 字节） + PDU（功能码+数据） + CRC（2 字节）</strong><ul><li><strong>从机地址</strong>：设备地址（1~247）</li><li><strong>PDU</strong>：功能码 + 数据（与 TCP 相同）</li><li><strong>CRC 校验</strong>：2 字节循环冗余校验（确保数据完整性）</li></ul></li></ul><p><strong>示例（读取寄存器 0x0000~0x0015）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>01 03 00 00 00 15 44 0C</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><code>01</code>：从机地址</li><li><code>03</code>：功能码（读寄存器）</li><li><code>00 00</code>：起始地址</li><li><code>00 15</code>：寄存器数量</li><li><code>44 0C</code>：CRC 校验</li></ul><hr><h2 id="_3-主要区别总结" tabindex="-1"><strong>3. 主要区别总结</strong> <a class="header-anchor" href="#_3-主要区别总结" aria-label="Permalink to &quot;**3. 主要区别总结**&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>对比项</strong></th><th><strong>Modbus-TCP</strong></th><th><strong>Modbus-RTU</strong></th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>工业以太网、远程监控</td><td>本地设备通信（PLC、传感器）</td></tr><tr><td><strong>传输距离</strong></td><td>理论上无限（依赖网络）</td><td>通常 ≤ 1200 米（RS485）</td></tr><tr><td><strong>数据校验</strong></td><td>依赖 TCP/IP 校验</td><td>使用 CRC 校验</td></tr><tr><td><strong>设备数量</strong></td><td>支持大规模组网</td><td>最多 247 个设备（RS485）</td></tr><tr><td><strong>通信速率</strong></td><td>快（100Mbps+）</td><td>较慢（通常 9600~115200bps）</td></tr><tr><td><strong>实现复杂度</strong></td><td>需要 IP 网络支持</td><td>只需串口通信</td></tr></tbody></table><hr><h2 id="_4-如何选择" tabindex="-1"><strong>4. 如何选择？</strong> <a class="header-anchor" href="#_4-如何选择" aria-label="Permalink to &quot;**4. 如何选择？**&quot;">​</a></h2><ul><li><p><strong>选 Modbus-TCP</strong>：</p><ul><li>需要远程监控（通过互联网）</li><li>高速、大数据量通信（如 SCADA 系统）</li><li>设备支持以太网（如工业网关、智能仪表）</li></ul></li><li><p><strong>选 Modbus-RTU</strong>：</p><ul><li>本地设备通信（PLC、传感器、仪表）</li><li>低成本、低功耗（RS485 硬件简单）</li><li>短距离、抗干扰强（工业现场）</li></ul></li></ul><hr><h2 id="_5-协议转换" tabindex="-1"><strong>5. 协议转换</strong> <a class="header-anchor" href="#_5-协议转换" aria-label="Permalink to &quot;**5. 协议转换**&quot;">​</a></h2><p>如果设备仅支持 <strong>Modbus-RTU</strong>，但需要通过 <strong>Modbus-TCP</strong> 访问，可以使用：</p><ul><li><strong>RS485 转 TCP 网关</strong>（如 MOXA NPort、USR-TCP232）</li><li><strong>软件转换</strong>（如 <code>pymodbus</code> 库的 RTU-over-TCP 模式）</li></ul><hr><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>Modbus-TCP</strong> 适用于 <strong>以太网环境</strong>，适合远程、高速通信。</li><li><strong>Modbus-RTU</strong> 适用于 <strong>串口环境</strong>，适合本地、低成本设备通信。</li><li><strong>两者 PDU 相同</strong>，主要区别在物理层和帧头结构。</li></ul><p>如果你的设备文档要求 <strong>Modbus-RTU</strong>，但代码用了 <strong>Modbus-TCP</strong>，通信会失败，需调整协议或使用网关转换！</p>',32)]))}const h=o(n,[["render",l]]);export{b as __pageData,h as default};
