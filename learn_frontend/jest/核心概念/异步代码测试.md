# 测试异步代码

[[toc]]

## 概述

在 JavaScript 中，代码异步运行是很常见的。当你有异步运行的代码时，Jest 需要知道它正在测试的代码何时完成，才能继续进行其他测试。Jest 有几种方法可以处理这个问题。

## 回调函数测试

### 基本模式

```js
test('异步回调测试', (done) => {
  function fetchData(callback) {
    setTimeout(() => {
      callback('peanut butter');
    }, 100);
  }

  fetchData((data) => {
    expect(data).toBe('peanut butter');
    done(); // 告诉Jest测试完成
  });
});
```

### 注意事项

1. 必须调用 done() 回调，否则测试会超时
2. Jest 会等待 done() 被调用才结束测试
3. 默认超时时间为 5 秒，可通过 `jest.setTimeout()` 修改

## Promise 测试

### 直接返回 Promise

```js
test('Promise测试 - 直接返回', () => {
  function fetchData() {
    return new Promise((resolve) => {
      setTimeout(() => resolve('peanut butter'), 100);
    });
  }

  return fetchData().then((data) => {
    expect(data).toBe('peanut butter');
  });
});
```

### 使用 .resolves/.rejects 匹配器

- resolves 匹配器用于测试兑现的 Promise，如果 expect 中的异步方法得到的是一个兑现的 Promise，则测试通过
- rejects 匹配器用于测试拒绝 Promise，如果 expect 中的异步方法得到的是一个拒绝的 Promise，则测试通过

```js
test('Promise测试 - resolves匹配器', () => {
  function fetchData() {
    return Promise.resolve('peanut butter');
  }
  // 期望这个异步方法会兑现且兑现为'peanut butter'
  return expect(fetchData()).resolves.toBe('peanut butter');
});

test('Promise测试 - rejects匹配器', () => {
  function fetchData() {
    return Promise.reject('error');
  }
  // 期望fetchData()返回Promise.reject('error')
  return expect(fetchData()).rejects.toBe('error');
});
```

### 注意事项

对于异步方法的测试必须在测试中显式 return 或 await 异步操作，否则测试会是同步方法，在 Promise 完成前提前结束，导致断言失效

```js
test('会漏测', () => {
  fetchData().then((data) => {
    expect(data).toBe('peanut butter'); // 可能不会执行
  });
  // 测试在此结束，不会等待 Promise
});
```

正确做法 ​：

```js
// 方法1：返回 Promise
test('正确做法 - return', () => {
  return fetchData().then((data) => {
    expect(data).toBe('peanut butter');
  });
});

// 方法2：使用 async/await
test('正确做法 - await', async () => {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});
```

## Async/Await 测试

### 基本使用

```js
test('Async/Await测试', async () => {
  function fetchData() {
    return Promise.resolve('peanut butter');
  }

  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

test('Async/Await错误测试', async () => {
  function fetchData() {
    return Promise.reject('error');
  }

  await expect(fetchData()).rejects.toBe('error');
});
```

### 结合 try/catch

```js
test('Async/Await try/catch测试', async () => {
  function fetchData() {
    return Promise.reject('error');
  }

  try {
    await fetchData();
  } catch (e) {
    expect(e).toBe('error');
  }
});
```

## 并发测试

```js
test('并发Promise测试', async () => {
  async function fetchUser() {
    return { name: 'Alice' };
  }

  async function fetchPosts() {
    return ['post1', 'post2'];
  }

  const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);

  expect(user.name).toBe('Alice');
  expect(posts).toHaveLength(2);
});
```

## 错误处理

```js
test('异步错误测试 - Promise', () => {
  function fetchData() {
    return Promise.reject(new Error('network error'));
  }

  return expect(fetchData()).rejects.toThrow('network error');
});

test('异步错误测试 - async/await', async () => {
  function fetchData() {
    return Promise.reject(new Error('network error'));
  }

  await expect(fetchData()).rejects.toThrow('network error');
});
```
