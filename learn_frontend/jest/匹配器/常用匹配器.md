# 常用匹配器

[[toc]]

## 基本概念

Jest 使用匹配器以不同方式测试值。本文档将介绍一些常用的匹配器。完整列表请参见 [expect API](https://jestjs.io/docs/expect) 文档。

## 常用匹配器

### 两个值是否相等-toBe

```js
test('two plus two is four', () => {
  expect(2 + 2).toBe(4);
});
```

在这段代码中，`expect(2 + 2)` 返回一个“期望值”对象。你通常不会对这些期望值对象做太多操作，除了调用匹配器。在这段代码中，`.toBe(4)` 是匹配器。当 Jest 运行时，它会跟踪所有失败的匹配器，以便为你打印出漂亮的错误信息。

### 两个对象是否相等-toEqual

`toBe` 使用 `Object.is` 来测试精确相等。如果你想检查对象的值，请使用 `toEqual`

```js
test('object assignment', () => {
  const data = { one: 1 };
  data['two'] = 2;
  expect(data).toEqual({ one: 1, two: 2 });
});
```

::: warning toEqual 是宽松相等检查

- 对象中值为 `undefined` 的属性键 ​：`{a: 1, b: undefined}` 会被认为等于 `{a: 1}`
- 数组中的 `undefined` 项 ​：`[1, undefined, 3]` 会被认为等于 `[1, , 3]`（稀疏数组）
- 数组的稀疏性 ​：`[1, , 3]`（稀疏数组）和 `[1, undefined, 3]` 会被认为相等
- 对象类型不匹配 ​：例如类实例和普通对象可能被认为相等

下面的测试案例会通过：

```js
test('toEqual', () => {
  // 通过 - toEqual 忽略 undefined 属性
  expect({ a: 1, b: undefined }).toEqual({ a: 1 });

  // 通过 - toEqual 认为稀疏数组和 undefined 数组项相同
  expect([1, , 3]).toEqual([1, undefined, 3]);
});
```

:::

### 对象严格相等检查-toStrictEqual

`toStrictEqual` 是一个更严格的检查，它会考虑上述所有情况：

- 会检查对象中 `undefined` 的属性是否存在
- 会区分数组中的显式 `undefined` 和稀疏项
- 会检查对象的具体类型是否匹配

下面的案例会失败：

```js
test('toStrictEqual', () => {
  // 失败 - toStrictEqual 检查 undefined 属性
  expect({ a: 1, b: undefined }).toStrictEqual({ a: 1 });

  // 失败 - toStrictEqual 区分稀疏数组和 undefined 项
  expect([1, , 3]).toStrictEqual([1, undefined, 3]);
});
```

## Truthiness 真值性

在测试中，你有时需要区分 `undefined`、`null` 和 `false`，但有时你又不想对它们进行不同的处理。Jest 提供了帮助函数，让你可以明确表达你的意图。

- `toBeNull`: 只匹配 `null`
- `toBeUndefined` : 只匹配 `undefined`
- `toBeDefined` : `toBeDefined` 与 `toBeUndefined` 相反
- `toBeTruthy` : 匹配任何被 if 语句视为真的内容。
- `toBeFalsy` : 匹配任何被 if 语句视为假值的内容

比如下面的例子会通过:

```js
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
```

## Numbers 数字

大多数比较数字的方法都有对应的匹配器。

- `toBeGreaterThan` : 大于
- `toBeGreaterThanOrEqual` : 大于等于
- `toBeLessThan` : 小于
- `toBeLessThanOrEqual` : 小于等于

```js
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
```

对于浮点数的相等性，使用 `toBeCloseTo` 而不是 toEqual，因为你不希望测试依赖于微小的舍入误差。

```js
test('adding floating point numbers', () => {
  const value = 0.1 + 0.2;
  //expect(value).toBe(0.3);           This won't work because of rounding error
  expect(value).toBeCloseTo(0.3); // This works.
});
```

## Strings 字符串

你可以用 `toMatch` 来用正则表达式检查字符串：

```js
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
```

## Arrays and iterables 数组和可迭代对象

你可以用 toContain 来检查数组或可迭代对象是否包含特定的项：

```js
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('the shopping list has milk on it', () => {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});
```

## Exceptions 异常
