# 起步

[[toc]]

## 基本概念及特点

`Mock Service Worker（MSW）`是一个用于浏览器和 Node.js 的 API 模拟库。使用 MSW，你可以拦截外发请求，观察它们，并用模拟响应进行响应。其特点如下：

- 跨平台支持：无需为不同环境编写不同 mock 逻辑，无缝运行在浏览器（基于 Service Worker）和 Node.js（基于类扩展）环境
- 框架无关性：兼容 `React/Vue/Angular/Svelte` 等任何前端框架，支持原生 `fetch、XMLHttpRequest` 及 `Axios/React Query/Apollo` 等第三方库
- 基于浏览器标准 API：通过 `Service Worker` 在网络层拦截请求，而非劫持或修改 `fetch/XHR` 实现，保持应用代码纯净
- 动态行为控制：支持运行时修改 mock 响应（如模拟错误状态、延迟返回等）
- 版本化管理：mock 规则可纳入代码仓库，与业务逻辑同步迭代

## 基本使用

### 安装

使用 npm 安装：`npm i msw --save-dev`

### 准备项目结构

```bash
src
 ├── api
 │   └── userApi.ts   # 接口文件
 ├── handler
 │   ├── index.ts     # 拦截器注册文件
 │   └── userController.ts  # 拦截器文件
 ├── utils
 │   └── request.ts     # 请求库文件
 └── __test__
     └── userApi.test.ts   # 测试文件
```

### 准备请求接口

请求采用 axios 库来发送

- 接口地址为`http://localhost:3000/api/users/list`
- 方法为 Get。

::: code-group

```js [axios配置]
import axios from 'axios';

export const request = axios.create({
  baseURL: 'http://localhost:3000/api',
});
```

```js [api接口]
import { request } from '../utils/request';

export async function getUserList() {
  return request.get('/users/list');
}
```

:::

### 编写请求拦截器

请求拦截器就是请求处理程序，会对具体请求进行拦截并返回响应的函数，其包含两个部分

- 断言谓词：路径匹配规则，决定拦截哪些请求
- 响应解析器：处理请求返回响应

如下所示：

```js
import { http, HttpResponse } from 'msw';
export const userController = [
  http.get('http://localhost:3000/api/users/list', () => {
    return HttpResponse.json({
      id: 'abc-123',
      firstName: 'John',
      lastName: 'Maverick',
    });
  }),
];
```

解释：

- 该拦截器对 `GET` 请求 `http://localhost:3000/api/users/list` 进行拦截（也就是准备的 axios 接口）
- 并返回一个 `JSON` 格式的响应，其中包含 `id`、`firstName`、`lastName` 三个字段

### 注册拦截器

拦截器需要注册到 MSW 中才能生效，如下所示：

```js
import { userController } from './userController';
import { setupServer } from 'msw/node';
export const server = setupServer(...userController);
```

解释：

1. 对于创建的拦截器需要通过 `setupServer`（node 环境）/`setupWorker`（浏览器环境） 方法注册到 MSW 中，并传入拦截器数组作为参数。
2. 注册完成后，MSW 会自动拦截所有匹配的请求，并 server 对象用于启动服务。

### 启动服务

启动服务在测试文件中进行，使用 jest 测试框架，如下所示：

```js [启动服务并测试]
import { getUserList } from '../api/userApi';
import { server } from '../handler';
// 测试启动前准备工作
beforeAll(() => {
  server.listen();
});
afterEach(() => {
  server.resetHandlers();
});
// 测试结束后清理工作
afterAll(() => {
  server.close();
});
describe('userApi', () => {
  test('getUserList', async () => {
    const result = await getUserList();
    expect(result.status).toBe(200);
    expect(result.data).toEqual({
      id: 'abc-123',
      firstName: 'John',
      lastName: 'Maverick',
    });
  });
});
```

解释：

- 在测试文件中，首先调用 `server.listen()` 方法启动服务。
- 在每个测试用例执行前，调用 `server.resetHandlers()` 方法重置拦截器，确保每个测试用例的请求都经过 MSW 拦截。
- 在测试用例执行后，调用 `server.close()` 方法关闭服务。
- 在测试用例中，调用 `getUserList` 方法获取用户列表，并断言其状态码为 `200` 且响应数据与预期一致。

运行结果如下:

```bash
PASS  src/__test__/userApi.test.ts
userApi
  √ getUserList (42 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.819 s
Ran all test suites.
```

## 默认行为

### 默认通过策略

- `MSW` ​ 默认不会拦截普通的 `HTTP` 请求（如 `fetch、XMLHttpRequest`），除非你在代码中显式编写了匹配的处理程序（`handler`）​。
- 由于 `WebSocket` 协议本身的技术限制 ​（如长连接、双向通信），MSW ​ 默认会尝试拦截 ​ `WebSocket` 请求，即使没有显式定义 `handler`。

### 处理程序穿透

当拦截到一个请求（如 `GET /user`）时，MSW 会按处理程序数组的顺序 ​（从上到下/从左自右）执行每个匹配的 `handler`，直到某一个 `handler` 返回响应后，才会停止穿透。

```js
export const handlers = [
  http.get('/user', () => console.log('One')), // ① 第一个匹配，执行打印
  http.get('/user', () => HttpResponse.json({ name: 'John' })), // ② 返回响应，终止穿透
  http.get('/user', () => console.log('Three')), // ③ 被忽略
];
```

### 处理程序执行顺序

源自于穿透行为，处理程序对其定义的顺序很敏感。MSW 按照从左到右的顺序执行它们，从处理程序覆盖开始，如果有的话，因为这些覆盖会被添加到处理程序列表的前面

```js
import { http, HttpResponse } from 'msw';
import { setupServer } from 'msw/node';

export const handlers = [
  http.get('/user', () => console.log('One')),
  http.get('/user', () => console.log('Two')),
  http.get('/user', () => console.log('Three')),
];

const server = setupServer(...handlers);
server.listen();

server.use(http.get('/user', () => console.log('Override one')));
```

给定一个发出的 `GET /user` 请求，你将在控制台中看到：

```js
Override one
One
Two
Three
```

利用处理程序顺序的敏感性来区分模糊的请求匹配：

```js
export const handlers = [
  // By placing a more specific request predicate first,
  // the "GET /user/messages" request will be handled
  // properly, despite it also matching a more permissive
  // "/user/*" handler below.
  http.get('/user/messages', messagesResolver)
  http.get('/user/*', resolverOne),
]
```
