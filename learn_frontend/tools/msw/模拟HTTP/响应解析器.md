# 响应解析器

[[toc]]

响应解析器是请求处理拦截器的组成部分，它是一个函数，负责处理请求返回响应

## 响应解析器的参数

响应解析器是一个函数包含如下参数：

| Property    | Type                                 | Description                                                                                             |
| ----------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------- |
| `request`   | `Request`                            | Fetch API Request representation of the intercepted request.<br>获取 API Request 表示被拦截请求的内容。 |
| `requestId` | `string`                             | UUID representing the intercepted request.<br>代表被拦截请求的 UUID                                     |
| `params`    | `Record<string, string \| string[]>` | Request path parameters (e.g. `:userId`).<br>请求路径参数（例如 `:userId`）                             |
| `cookies`   | `Record<string, string>`             | Parsed request cookies.<br>解析的请求 cookies.                                                          |

```js
http.get('/resource', ({ request, params, cookies }) => {});
```

## 处理路径参数

### 获取一般路径参数

你可以通过在请求处理程序的路径中包含冒号`:`后跟参数名来定义路径参数

```js
//         👇 describe parameter types
http.get < { id: string } > ('/posts/:id', () => {});
//
```

路径参数表示请求 URL 中的动态部分，不会被字面匹配。相反，参数位置上的任何字符串都将存储在响应解析器参数中暴露的 `params` 对象中，你可以通过响应解析器参数中的 params 对象访问路径参数的值。

```js
http.get <
  { id: string } >
  ('/posts/:id',
  ({ params }) => {
    const { id } = params;
  });
```

### 获取重复路径参数

将加号（`+`）用作路径参数的后缀，以表示其值重复。重复的路径参数将在 `params` 对象中以值数组的形式表示。

```js
http.get<{ segments: string[] }>('/settings/:segments+', ({ params }) => {
  console.log(params.segments)
})
```

| Request URL                   | params.segments               |
| ----------------------------- | ----------------------------- |
| `/settings/user`              | `["user"]`                    |
| `/settings/user/privacy`      | `["user", "privacy"]`         |
| `/settings/user/profile/edit` | `["user", "profile", "edit"]` |

## 处理查询参数

### 读取单个查询参数

您可以通过从`request.url`字符串创建 URL 并访问其`searchParams`属性来读取请求的查询参数。

```js
http.get('/product', ({ request }) => {
  const url = new URL(request.url);

  // Given a request url of "/product?id=1",
  // the `productId` will be a "1" string.
  const productId = url.searchParams.get('id');

  if (!productId) {
    return new HttpResponse(null, { status: 404 });
  }

  return HttResponse.json({ id: productId });
});
```

`url.searchParams` 是 `URLSearchParams` 的一个实例，这意味着你可以使用像 `.get()` 和 `.getAll()` 这样的方法获取查询参数的值。

### 读取多值查询参数

`URLSearchParams.prototype.getAll()` 方法获取多值查询参数的值列表。

```js
http.get('/products', ({ request }) => {
  const url = new URL(request.url);

  // Given a request url of "/products?id=1&id=2&id=3",
  // the `productIds` will be an array of ["1", "2", "3"].
  const productIds = url.searchParams.getAll('id');
});
```

### 写入查询参数

虽然 request 对象代表一个已经发生的 Fetch API 请求 ，且无法更改，但你仍然可以添加、修改或删除其查询参数，如果你希望 将该请求转发到其他地方。

```js
http.get('/user', ({ request }) => {
  const url = new URL(request.url);
  url.searchParams.set('id', 'another-id');

  // Create a proxy request that extends the intercepted request
  // but has modified query parameters in its URL.
  const proxyRequest = new Request(url, request);
});
```

## 处理请求体

您可以像通常读取任何 Fetch API 请求一样读取截获的请求体。在响应解析器参数中获得的请求对象实际上是一个常规的请求实例，并且可以按此操作。
例如，你可以调用 `await request.json()` 来将请求的正文作为 JSON 读取，

```js
http.post < { id: string },
  Post >
    ('/posts/:id',
    async ({ request }) => {
      const newPost = await request.clone().json(); // Post
    });
```

::: warning 注意
强烈建议在读取拦截请求的 body 之前先 克隆 一份请求。虽然如果你打算模拟响应，直接读取请求体是可以的，但在 `passthrough`绕过场景中不进行克隆就读取请求体会导致异常（流不能被重复读取）。对于其他方法，如 `.text()、.formData()、.blob()` 等，也是如此。
:::

## 处理 Cookies

您可以通过响应解析器参数中提供给您的 `cookie` 对象读取请求的 `cookie`。虽然您总是可以手动读取 `request.headers.get（'cookie'）`，但为了方便起见，`cookie` 对象会为您解析请求 `cookie`。

```js
http.get('/api/user', ({ cookies }) => {
  if (!cookies.authToken) {
    return new HttpResponse(null, { status: 403 });
  }

  return HttpResponse.json({ name: 'John' });
});
```

## 模拟响应

### 响应的三部分

1. 响应状态码：HTTP 状态码，如 200、404、500 等

```js
http.get('/resource', () => {
  return new HttpResponse(null, { status: 404 });
});
```

2. 响应头

```js
http.get('/resource', () => {
  return HttpResponse.json(
    { id: 'abc-123' },
    {
      headers: {
        'content-type': 'application/hal+json',
      },
    }
  );
});
```

3. 响应体

你可以使用所有支持的响应体类型，比如字符串、`Blob、ArrayBuffer、FormData、URLSearchParams` 和 `ReadableStream` 作为模拟响应的正文。

```js
http.get('/resource', () => {
  return HttpResponse.text('hello world');
});
```

### 返回原始响应-passthrough

你可以按原样执行被拦截的请求，并返回其原始响应（即透传请求），方法是返回 `passthrough()`函数调用的结果

```js
import { passthrough } from 'msw';

http.get('/resource', () => {
  return passthrough();
});
```

当你只想在特定情况下模拟响应，而在其他情况下按原样执行请求时，这尤其有用。

```js
http.get('https://api.example.com/resource', async ({ request }) => {
  const data = await request.clone().json();

  if (data?.id === 'abc-123') {
    return HttpResponse.json({ id: 'abc-123' });
  }

  return passthrough();
});
```

### 不返回任何内容

您也可以显式或隐式地从响应解析器中不返回任何内容。如果发生这种情况，MSW 将继续寻找可能匹配此请求的其他请求处理程序。您可以将其用于网络自检或任何其他不涉及响应请求的副作用。

```js
export const handlers = [
  http.get('/resource', ({ request }) => {
    console.log('Request intercepted!', request.method, request.url);
  }),
  http.get('/resource', () => {
    return HttpResponse.text('hello world');
  }),
];
```

解释：在这个例子中，第一个请求处理程序将会匹配，记录消息到控制台，并且由于它没有返回任何内容，处理结束。然后，第二个请求处理程序将会匹配同样的请求，并用一个模拟的响应来处理它，作为一个示例。

### 错误响应

你可以通过构造一个有效的错误 `Response` 实例并从响应解析器返回它，来对拦截的请求做出错误响应。这意味着使用错误状态码（`4xx/5xx`）并可选地提供任何自定义的响应负载，例如错误信息。

```js
http.get <
  { id: string } >
  ('/books/:id',
  ({ params }) => {
    if (params.id === 'abc-123') {
      return new HttpResponse(null, { status: 404 });
    }

    return HttpResponse.json({
      id: params.id,
      title: 'The Lord of the Rings',
    });
  });
```

### 网络错误

你可以用 `Response.error()` 来响应被拦截的请求，这个标签用来表示网络错误。`Response.error()` 静态方法会返回一种特殊的 `Response` 实例，这种实例不会被当作普通的服务器响应处理。相反，它会导致网络错误，中止待处理的请求。

```js
http.get('/resource', () => {
  return HttpResponse.error();
});
```

使用 `Response.error()` 方法模拟网络错误，例如：

- DNS 错误
- 连接超时
- 客户端离线

`WHATWG Fetch API` 规范没有提供自定义网络错误信息的方法，因此你的客户端会收到一个通用的 `TypeError: Failed to fetch` 错误，你需要在请求的 `.catch()` 回调中处理这个错误。

### 二进制响应

你可以向模拟响应实例提供一个 `ArrayBuffer`，以响应二进制数据，比如图片、视频或音频。

```js
http.get('/images/:imageId', async ({ params }) => {
  // Get an ArrayBuffer from reading the file from disk or fetching it.
  const buffer = await fetch(`/static/images/${params.imageId}`).then(
    (response) => response.arrayBuffer()
  );

  return HttpResponse.arrayBuffer(buffer, {
    headers: {
      'content-type': 'image/png',
    },
  });
});
```

使用`HttpResponse.arrayBuffer()`静态方法将自动在模拟响应上设置`content-length`。确保仍然设置适当的`content-type`头！

### 模拟 cookie

使用直接的 `Fetch API Response` 实例模拟响应 `cookies` 证明存在问题，因为 `Set-Cookie` 头是不能设置的禁止的头之一。MSW 在其 `HttpResponse` 类中绕过了这一限制，允许你模拟响应 `cookies`而不影响响应的完整性和安全性。

```js
http.post('/login', () => {
  return new HttpResponse(null, {
    headers: {
      // Setting the "Set-Cookie" header on the mocked response
      // will set the cookies on the `document` as if they were
      // received from the server.
      'set-cookie': 'authToken=abc-123',
    },
  });
});
```

### 重定向

你可以通过构建一个有效的重定向 `Response` 实例并从响应解析器中返回它来模拟重定向响应。这意味着设置一个重定向状态码 (3xx) 和指向目标 URL 的 `location` 头部。

```js
http.get('/resource-a', () => {
  return new HttpResponse(null, {
    status: 301,
    headers: {
      location: '/resource-b',
    },
  });
});
```

### 生成器函数

你可以在 JavaScript 中使用生成器函数（包括异步生成器）在每次对同一处理程序的后续请求中产生不同的响应。这在描述 HTTP 轮询时特别方便

```js
http.get<{ city: string }, never, { degree: number }>(
  '/weather/:city',
  function* () {
    let degree = 25

    while (degree < 27) {
      degree++
      yield HttpResponse({ degree })
    }

    degree++
    return HttpResponse.json({ degree })
  },
)
```

这个 `GET /wheather/:city` 请求处理程序在每次响应时增加 `degree`，直到达到 28 度：

```js
GET / weather / london; // { "degree": 26 }
GET / weather / london; // { "degree": 27 }
GET / weather / london; // { "degree": 28 }

// All subsequent requests will respond
// with the latest returned response.
GET / weather / london; // { "degree": 28 }
```

### 流响应

你可以通过构建一个 `ReadableStream` 实例并将其作为模拟响应的正文，来用数据流响应被拦截的请求。

```js
http.get('/stream', () => {
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode('hello'));
      controller.enqueue(new TextEncoder().encode('world'));
      controller.close();
    },
  });

  return new HttpResponse(stream, {
    headers: {
      'content-type': 'text/plain',
    },
  });
});
```

你可以使用 Fetch API 支持的任何类型的 Web 流作为模拟的响应体，比如一个 `TransformStream`。这里是一个在获取原始响应流并在其块之间插入延迟的复合场景，使用 `TransformStream`：

```js
import { http, HttpResponse, delay } from 'msw';

http.get('/video/:id', async ({ params }) => {
  const videoResponse = await fetch(
    `https://api.example.com/videos/${params.id}`
  );
  const videoStream = videoResponse.body;

  const latencyStream = new TransformStream({
    start() {},
    async transform(chunk, controller) {
      await delay(1000);
      controller.enqueue(chunk);
    },
  });

  return new HttpResponse(
    videoStream.pipeThrough(latencyStream),
    videoResponse
  );
});
```

### 响应时间

你可以使用 MSW 的 `delay()` 函数来控制拦截请求时的服务器响应时间。在底层，`delay()` 函数会返回一个在一定时间后解决的 `promise`。

```js
import { http, HttpResponse, delay } from 'msw';

http.get('/resource', async () => {
  await delay(500);
  return HttpResponse.json({ id: 'abc-123' });
});
```

您可以在响应解析的任何时候使用 `delay()`，包括在流式块之间，如果 以流方式响应：

```js
http.get('/stream', () => {
  const stream = new ReadableStream({
    async start(controller) {
      controller.enqueue(new TextEncoder().encode('hello'))
      await delay(200)
      controller.enqueue(new TextEncoder().encode('world'))
      await delay(300)
      controller.close()
    },
  })

  return new HttpResponse(stream, { ... })
})
```

有时您可能希望引入影响所有请求 的延迟。有几种方法可以实现

1.延迟穿透处理程序：利用请求处理程序的执行顺序，添加一个请求处理程序，只等待一个延迟 在 其他处理程序之前

```js
export const handlers = [
  http.all('*', async () => {
    await delay(500);
  }),

  // ...other request handlers.
];
```

2. 高阶解析器：另一种选择是定义一个 高阶响应解析器，它封装延迟逻辑，并有选择地将其应用于某些响应解析器

```js
import { delay, type HttpResponseResolver } from 'msw';

export async function withDelay(resolver: HttpResponseResolver) {
  return async (...args) => {
    // Provide no arguments to the `delay` function
    // to apply a random realistic response time.
    await delay();
    return resolver(...args);
  };
}
```

然后，你可以在请求处理程序中使用 `withDelay()` 函数包装响应解析器：

```js
import { withDelay } from './with-delay';

export const handlers = [
  http.get(
    '/user',
    withDelay(({ request }) => {
      return HttpResponse.json({ id: 'abc-123' });
    })
  ),
  http.post(
    '/cart/:cartId',
    withDelay(() => {
      return new HttpResponse(null, { status: 201 });
    })
  ),
  http.get('/products', () => {
    return HttpResponse.json([1, 2, 3]);
  }),
];
```

::: tip 隐式延迟
当不带任何参数调用时，delay 函数会应用一个 真实的服务器响应时间。它是一个随机数，等于你在与实际 HTTP 服务器通信时遇到的平均响应时间（大约 100-400 毫秒）。
:::

::: tip 延迟模式

MSW 提供了两种延迟模式：

- "real"：明确设置逼真响应时间；
- "infinite"，无限期延迟响应，使其永远悬而未决

:::

### 文件上传

网页上的文件上传通常通过提交一个 POST 请求，并在 FormData 体中包含文件。你可以拦截该请求，并使用拦截的 Fetch API Request 实例上的 formData() 方法读取其主体为 FormData。

```js
import { http, HttpResponse } from 'msw';

export const handlers = [
  http.post('/upload', async ({ request }) => {
    const data = await request.formData();
    const file = data.get('file');

    if (!file) {
      return new HttpResponse('Missing document', { status: 400 });
    }

    if (!(file instanceof File)) {
      return new HttpResponse('Uploaded document is not a File', {
        status: 400,
      });
    }

    return HttpResponse.json({
      contents: await file.text(),
    });
  }),
];
```

您可以以任何您喜欢的方式上传文件。以下是使用 `JavaScript`中的`fetch()`函数将纯文本`doc.txt`文档 发送到服务器的示例

```js
const data = new FormData();
const file = new Blob(['Hello', 'world'], { type: 'text/plain' });
data.set('file', file, 'doc.txt');

fetch('/upload', {
  method: 'POST',
  body: data,
});
```

### 代理请求

您可以通过构建代理`Fetch API Request`实例并使用`bypass()`函数执行它来代理拦截的请求，以防止它再次匹配同一请求处理程序。这可以将您的 MSW 设置变成影响本地和外部流量的代理服务器。

```js
import { http, bypass } from 'msw';

export const handlers = [
  http.get('/resource', async ({ request }) => {
    const originalUrl = new URL(request.url);

    // Modify the original URL to point to a different server.
    originalUrl.hostname = 'api.example.com';

    // Construct a proxy request.
    const proxyRequest = new Request(proxyUrl, {
      headers: {
        'content-type': request.headers.get('Content-Type'),
        'x-proxy-header': 'abc-123',
      },
    });

    // Perform the proxy request.
    const originalResponse = await fetch(bypass(proxyRequest));

    // Continue handling the request...
  }),
];
```

### 响应修补

你可以结合原始响应和模拟响应，使用一种称为 响应修补 的技术。它涉及按原样执行被拦截的请求，获取其原始响应，然后根据需要进行修改
使用 `bypass()` 函数从 msw 执行任何 `Fetch API Request`，绕过任何匹配的请求处理程序，并防止由你使用 `bypass()` 的处理程序引起的无限循环

```js
import { http, HttpResponse, bypass } from 'msw';

http.get('/resource', async ({ request }) => {
  // Get the original JSON response from the server.
  const originalData = await fetch(bypass(request)).then((response) =>
    response.json()
  );

  return HttpResponse.json({
    // Combine the original data with the mocked data.
    ...originalData,
    id: 'mocked-id',
  });
});
```
