# 响应解析器

[[toc]]

响应解析器是请求处理拦截器的组成部分，它是一个函数，负责处理请求返回响应

## 响应解析器的参数

响应解析器是一个函数包含如下参数：

| Property    | Type                                 | Description                                                                                             |
| ----------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------- |
| `request`   | `Request`                            | Fetch API Request representation of the intercepted request.<br>获取 API Request 表示被拦截请求的内容。 |
| `requestId` | `string`                             | UUID representing the intercepted request.<br>代表被拦截请求的 UUID                                     |
| `params`    | `Record<string, string \| string[]>` | Request path parameters (e.g. `:userId`).<br>请求路径参数（例如 `:userId`）                             |
| `cookies`   | `Record<string, string>`             | Parsed request cookies.<br>解析的请求 cookies.                                                          |

```js
http.get('/resource', ({ request, params, cookies }) => {});
```

## 处理路径参数

### 获取一般路径参数

你可以通过在请求处理程序的路径中包含冒号`:`后跟参数名来定义路径参数

```js
//         👇 describe parameter types
http.get < { id: string } > ('/posts/:id', () => {});
//
```

路径参数表示请求 URL 中的动态部分，不会被字面匹配。相反，参数位置上的任何字符串都将存储在响应解析器参数中暴露的 `params` 对象中，你可以通过响应解析器参数中的 params 对象访问路径参数的值。

```js
http.get <
  { id: string } >
  ('/posts/:id',
  ({ params }) => {
    const { id } = params;
  });
```

### 获取重复路径参数

将加号（`+`）用作路径参数的后缀，以表示其值重复。重复的路径参数将在 `params` 对象中以值数组的形式表示。

```js
http.get<{ segments: string[] }>('/settings/:segments+', ({ params }) => {
  console.log(params.segments)
})
```

| Request URL                   | params.segments               |
| ----------------------------- | ----------------------------- |
| `/settings/user`              | `["user"]`                    |
| `/settings/user/privacy`      | `["user", "privacy"]`         |
| `/settings/user/profile/edit` | `["user", "profile", "edit"]` |

## 处理查询参数

### 读取单个查询参数

您可以通过从`request.url`字符串创建 URL 并访问其`searchParams`属性来读取请求的查询参数。

```js
http.get('/product', ({ request }) => {
  const url = new URL(request.url);

  // Given a request url of "/product?id=1",
  // the `productId` will be a "1" string.
  const productId = url.searchParams.get('id');

  if (!productId) {
    return new HttpResponse(null, { status: 404 });
  }

  return HttResponse.json({ id: productId });
});
```

`url.searchParams` 是 `URLSearchParams` 的一个实例，这意味着你可以使用像 `.get()` 和 `.getAll()` 这样的方法获取查询参数的值。

### 读取多值查询参数

`URLSearchParams.prototype.getAll()` 方法获取多值查询参数的值列表。

```js
http.get('/products', ({ request }) => {
  const url = new URL(request.url);

  // Given a request url of "/products?id=1&id=2&id=3",
  // the `productIds` will be an array of ["1", "2", "3"].
  const productIds = url.searchParams.getAll('id');
});
```

### 写入查询参数

虽然 request 对象代表一个已经发生的 Fetch API 请求 ，且无法更改，但你仍然可以添加、修改或删除其查询参数，如果你希望 将该请求转发到其他地方。

```js
http.get('/user', ({ request }) => {
  const url = new URL(request.url);
  url.searchParams.set('id', 'another-id');

  // Create a proxy request that extends the intercepted request
  // but has modified query parameters in its URL.
  const proxyRequest = new Request(url, request);
});
```

## 处理请求体

您可以像通常读取任何 Fetch API 请求一样读取截获的请求体。在响应解析器参数中获得的请求对象实际上是一个常规的请求实例，并且可以按此操作。
例如，你可以调用 `await request.json()` 来将请求的正文作为 JSON 读取，

```js
http.post < { id: string },
  Post >
    ('/posts/:id',
    async ({ request }) => {
      const newPost = await request.clone().json(); // Post
    });
```

::: warning 注意
强烈建议在读取拦截请求的 body 之前先 克隆 一份请求。虽然如果你打算模拟响应，直接读取请求体是可以的，但在 `passthrough`绕过场景中不进行克隆就读取请求体会导致异常（流不能被重复读取）。对于其他方法，如 `.text()、.formData()、.blob()` 等，也是如此。
:::

## 处理 Cookies

您可以通过响应解析器参数中提供给您的 `cookie` 对象读取请求的 `cookie`。虽然您总是可以手动读取 `request.headers.get（'cookie'）`，但为了方便起见，`cookie` 对象会为您解析请求 `cookie`。

```js
http.get('/api/user', ({ cookies }) => {
  if (!cookies.authToken) {
    return new HttpResponse(null, { status: 403 });
  }

  return HttpResponse.json({ name: 'John' });
});
```

## 模拟响应

### 响应的三部分

1. 响应状态码：HTTP 状态码，如 200、404、500 等

```js
http.get('/resource', () => {
  return new HttpResponse(null, { status: 404 });
});
```

2. 响应头

```js
http.get('/resource', () => {
  return HttpResponse.json(
    { id: 'abc-123' },
    {
      headers: {
        'content-type': 'application/hal+json',
      },
    }
  );
});
```

3. 响应体

你可以使用所有支持的响应体类型，比如字符串、`Blob、ArrayBuffer、FormData、URLSearchParams` 和 `ReadableStream` 作为模拟响应的正文。

```js
http.get('/resource', () => {
  return HttpResponse.text('hello world');
});
```

### 返回原始响应-passthrough

你可以按原样执行被拦截的请求，并返回其原始响应（即透传请求），方法是返回 `passthrough()`函数调用的结果

```js
import { passthrough } from 'msw';

http.get('/resource', () => {
  return passthrough();
});
```

当你只想在特定情况下模拟响应，而在其他情况下按原样执行请求时，这尤其有用。

```js
http.get('https://api.example.com/resource', async ({ request }) => {
  const data = await request.clone().json();

  if (data?.id === 'abc-123') {
    return HttpResponse.json({ id: 'abc-123' });
  }

  return passthrough();
});
```

### 不返回任何内容

您也可以显式或隐式地从响应解析器中不返回任何内容。如果发生这种情况，MSW 将继续寻找可能匹配此请求的其他请求处理程序。您可以将其用于网络自检或任何其他不涉及响应请求的副作用。

```js
export const handlers = [
  http.get('/resource', ({ request }) => {
    console.log('Request intercepted!', request.method, request.url);
  }),
  http.get('/resource', () => {
    return HttpResponse.text('hello world');
  }),
];
```

解释：在这个例子中，第一个请求处理程序将会匹配，记录消息到控制台，并且由于它没有返回任何内容，处理结束。然后，第二个请求处理程序将会匹配同样的请求，并用一个模拟的响应来处理它，作为一个示例。
