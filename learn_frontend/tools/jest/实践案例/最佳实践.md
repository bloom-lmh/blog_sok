# 最佳实践

## 原则

- 测试文件命名：`*.test.js` 或 `*.spec.js`
- 将测试文件放在 `__tests__`目录或与源码同目录
- 每个测试用例应该小而专注
- 使用 `describe` 组织相关测试
- 测试应该独立不依赖其他测试的状态

## 错误处理

### 隔离测试

如果一个测试失败，首先要检查的事情之一应该是该测试在它是唯一运行的测试时是否也会失败。要用 Jest 只运行测试组中的一个测试，暂时将那个 test 命令改为 `test.only`：

```js
// 原代码
test.only('仅运行我', () => {
  console.log('这个测试会执行');
  expect(1 + 1).toBe(2);
});

test('不运行我', () => {
  console.log('这个不会执行');
  expect('A').toBe('A');
});

describe('普通测试组', () => {
  test('我也不运行', () => {
    console.log('describe 内的也被跳过');
  });
});
```

## 注意软删除

在 Jest 测试框架中，​ 软删除（Soft Deletion）​​ 是一种内存管理机制，目的是 ​ 防止测试之间的状态污染和内存泄漏。它的核心逻辑和存在原因如下：

### 为什么需要软删除？

### 软删除的工作原理

- 测试执行前 ​：`Jest` 会记录当前的全局状态（如 global、window、prototype）。
- ​ 测试执行后 ​：
  - ​ 软删除阶段 ​：将测试中新增或修改的全局对象标记为“可删除”，但仍保留在内存中。
  - ​ 警告阶段 ​：如果后续测试访问了被标记的对象，Jest 会发出 DeprecationWarning（如你遇到的 `[JEST-01]`）。

### 触发软删除的情况

| 操作类型     | 示例                                     | 是否触发软删除   |
| ------------ | ---------------------------------------- | ---------------- |
| 修改全局对象 | `global.myVar = 1`                       | ✅               |
| 修改类的原型 | `UserApi.prototype.newMethod = () => {}` | ✅               |
| 使用模拟库   | `nock('https://api.com').reply(200)`     | ✅（如果未清理） |
| 局部变量     | `const x = 1`                            | ❌               |

比如我在测试中
