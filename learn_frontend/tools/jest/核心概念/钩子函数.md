# 钩子函数

[[toc]]

## 基本概述

在编写测试时，通常会有一些在测试运行之前需要进行的设置工作，以及在测试运行之后需要完成的收尾工作。Jest 提供了辅助函数来处理这些工作。

## 重复设置-Repeating Setup

如果你有一些工作需要在多次测试中重复进行，你可以使用 `beforeEach` 和 `afterEach` 钩子。
例如，假设有几个测试会与城市数据库交互。你有一个方法 `initializeCityDatabase()`，必须在这些测试之前调用，以及一个方法 `clearCityDatabase()`，必须在这些测试之后调用。你可以这样做：”

```js
// 每个测试之前调用
beforeEach(() => {
  initializeCityDatabase();
});

// 每个测试之后调用
afterEach(() => {
  clearCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});
```

::: tip 处理异步的两种方式
如果`initializeCityDatabase()`是异步的，那么测试用例中想要用到`initializeCityDatabase()`方法返回的数据，则所有测试都需要等待这个方法执行完成。
`beforeEach` 和 `afterEach` 可以以与测试处理异步代码的方式相同的方式处理异步代码

1. 方法一：​ 返回 Promise​（现代推荐方式）

```js
beforeEach(() => {
  return initializeCityDatabase(); // 返回Promise，Jest会等待其解决
});
```

2. 方法二：​ 使用 done 回调 ​（传统方式）

```js
beforeEach((done) => {
  initializeCityDatabase().then(() => done()); // 手动调用done()
});
```

:::

::: warning 返回拒绝状态的 Promise
如果 `initializeCityDatabase()` 返回一个拒绝状态的 Promise，那么整个测试套件会认为测试失败。为了避免这种情况，可以将 `initializeCityDatabase()` 包裹在 `Promise.resolve()` 中，以确保其返回一个已解决的 Promise。
:::

## 一次性设置 One-Time Setup

在某些情况下，你只需要在文件开始时进行一次设置，而不是每次测试前都需要设置。这在设置是异步的情况下尤其麻烦，因此你不能在行内完成。Jest 提供了 `beforeAll` 和 `afterAll` 钩子来处理这种情况。

例如，如果 `initializeCityDatabase()` 和 `clearCityDatabase()` 都返回承诺，并且城市数据库可以在测试之间重用，我们可以将测试代码改为

```js
beforeAll(() => {
  return initializeCityDatabase();
});

afterAll(() => {
  return clearCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});
```

## 钩子函数的作用域-Scoping

顶层的 `before*` 和 `after*` 钩子适用于文件中的每个测试。在 `describe` 块内声明的钩子只适用于该 `describe` 块内的测试。
例如，假设我们不仅有一个城市数据库，还有一个食品数据库。我们可以为不同的测试做不同的设置：

```js
// Applies to all tests in this file
beforeEach(() => {
  return initializeCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});

describe('matching cities to foods', () => {
  // Applies only to tests in this describe block
  beforeEach(() => {
    return initializeFoodDatabase();
  });

  test('Vienna <3 veal', () => {
    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);
  });

  test('San Juan <3 plantains', () => {
    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);
  });
});
```

请注意，顶层的 `beforeEach` 在 `describe` 块内的 `beforeEach` 之前执行。这样可以帮助说明所有钩子的执行顺序

```js
beforeAll(() => console.log('1 - beforeAll'));
afterAll(() => console.log('1 - afterAll'));
beforeEach(() => console.log('1 - beforeEach'));
afterEach(() => console.log('1 - afterEach'));

test('', () => console.log('1 - test'));

describe('Scoped / Nested block', () => {
  beforeAll(() => console.log('2 - beforeAll'));
  afterAll(() => console.log('2 - afterAll'));
  beforeEach(() => console.log('2 - beforeEach'));
  afterEach(() => console.log('2 - afterEach'));

  test('', () => console.log('2 - test'));
});

// 1 - beforeAll
// 1 - beforeEach
// 1 - test
// 1 - afterEach
// 2 - beforeAll
// 1 - beforeEach
// 2 - beforeEach
// 2 - test
// 2 - afterEach
// 1 - afterEach
// 2 - afterAll
// 1 - afterAll
```

## 执行顺序-Order of Execution

### 先执行描述语句后执行测试用例原则

Jest 运行测试时会分为两个明确阶段：

1. 收集阶段（Collection Phase）​​

   - 先执行文件中所有的 describe 代码块（仅执行描述语句，不执行测试用例）
   - 此时会登记所有测试用例，但不会立即执行它们

2. 运行阶段（Execution Phase）​​
   - 默认按顺序串行执行测试用例（一个完成后才执行下一个）
   - 每个测试执行前/后会运行对应的 `before*/after*` 钩子

```js
describe('describe outer', () => {
  console.log('describe outer-a');

  describe('describe inner 1', () => {
    console.log('describe inner 1');

    test('test 1', () => console.log('test 1'));
  });

  console.log('describe outer-b');

  test('test 2', () => console.log('test 2'));

  describe('describe inner 2', () => {
    console.log('describe inner 2');

    test('test 3', () => console.log('test 3'));
  });

  console.log('describe outer-c');
});

// describe outer-a
// describe inner 1
// describe outer-b
// describe inner 2
// describe outer-c
// test 1
// test 2
// test 3
```

### 包裹范围内`after*` 钩子先调用原则

就像 describe 和 test 块一样，Jest 按照声明的顺序调用 `before*` 和 `after*` 钩子。请注意，包裹范围的 `after*` 钩子会先被调用。例如，以下是设置和拆除相互依赖资源的方法：

```js
beforeEach(() => console.log('connection setup'));
beforeEach(() => console.log('database setup'));

afterEach(() => console.log('database teardown'));
afterEach(() => console.log('connection teardown'));

test('test 1', () => console.log('test 1'));

describe('extra', () => {
  beforeEach(() => console.log('extra database setup'));
  afterEach(() => console.log('extra database teardown'));

  test('test 2', () => console.log('test 2'));
});

// connection setup
// database setup
// test 1
// database teardown
// connection teardown

// connection setup
// database setup
// extra database setup
// test 2
// extra database teardown
// database teardown
// connection teardown
```
