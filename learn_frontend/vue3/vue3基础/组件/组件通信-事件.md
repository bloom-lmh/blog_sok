# 组件事件

[[toc]]

## 发布事件

子组件能够通过发布事件来促使父组件产生变化进而影响自己,发布事件有两种方式：

### 模板中直接发布-$emit

在组件的模板表达式中，可以直接使用 `$emit` 方法触发自定义事件 (例如：在 `v-on` 的处理函数中)：

```html
<!-- MyComponent -->
<button @click="$emit('someEvent')">Click Me</button>
```

### 方法中发布-defineEmits

#### 数组语法

我们在 `<template>` 中可以使用的 `$emit` 方法来发布事件，但是不能在组件的 `<script setup>` 部分中使用，在组件中需要使用 `defineEmits()`来定义要发布的事件，这个方法会返回一个相同作用的函数供我们使用：

```vue
<script setup>
const emit = defineEmits(['inFocus', 'submit']);
function buttonClick() {
  emit('submit');
}
</script>
```

如果你显式地使用了 setup 函数而不是 `<script setup>`，则事件需要通过 emits 选项来定义，emit 函数也被暴露在 `setup()` 的上下文对象上：

```ts
export default {
  emits: ['inFocus', 'submit'],
  setup(props, ctx) {
    ctx.emit('submit');
  },
};
```

#### 对象语法

这个 `emits` 选项和 `defineEmits()` 宏还支持对象语法。通过 TypeScript 为参数指定类型，它允许我们对触发事件的参数进行验证：
:::code-group

```vue [完整可调用的函数形式]
<script setup lang="ts">
const emit = defineEmits({
  submit(payload: { email: string; password: string }) {
    // 通过返回值为 `true` 还是为 `false` 来判断
    // 验证是否通过
  },
});
</script>
```

如果你正在搭配 TypeScript 使用 `<script setup>`，也可以使用纯类型标注来声明触发的事件：

```vue [可调用的函数形式]
<script setup lang="ts">
const emit = defineEmits<{
  (e: 'change', id: number): void;
  (e: 'update', value: string): void;
}>();
</script>
```

```js [类型字面量形式]
// 3.3+: 可选的、更简洁的语法
const emit = defineEmits<{
  change: [id: number]
  update: [value: string]
}>()
```

:::

::: tip 当与原生事件重名时
如果一个原生事件的名字 (例如 click) 被定义在 emits 选项中，则监听器只会监听组件触发的 click 事件而不会再响应原生的 click 事件。
:::

### 发布事件时传递参数

在发布事件时可以传递参数，这在上面对象语法已经有所展示，如果要在模板中触发事件并传递参数你可以这样

```html
<button @click="$emit('increaseBy', 1)">Increase by 1</button>
```

### 事件校验

和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 emit 的内容，返回一个布尔值来表明事件是否合法。

```vue
<script setup>
const emit = defineEmits({
  // 没有校验
  click: null,

  // 校验 submit 事件
  submit: ({ email, password }) => {
    if (email && password) {
      return true;
    } else {
      console.warn('Invalid submit event payload!');
      return false;
    }
  },
});

function submitForm(email, password) {
  emit('submit', { email, password });
}
</script>
```

## 订阅事件

父组件可以订阅子组件发布的事件，并在事件发生时执行相应的逻辑。

## 监听事件并接受参数

父组件可以通过 v-on (缩写为 @) 来监听事件：

```vue
<MyComponent @some-event="callback" />
```

当然也可以接受事件参数：

```js
<MyButton @increase-by="n => (count += n)" />
// 或者
<MyButton @increase-by="increaseCount" />
function increaseCount(n) {
  count.value += n
}
```

::: tip 提示
所有传入 `$emit()` 的额外参数都会被直接传向监听器。举例来说，`$emit('foo', 1, 2, 3)` 触发后，监听器函数将会收到这三个参数值。
:::

### 事件修饰符

同样，组件的事件监听器也支持 `.once` 修饰符：

```vue
<MyComponent @some-event.once="callback" />
```

::: tip 提示
像组件与 `prop` 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 `camelCase` 形式命名的事件，但在父组件中可以使用 `kebab-case` 形式来监听。与 `prop` 大小写格式一样，在模板中我们也推荐使用 `kebab-case` 形式来编写监听器。
:::

### 事件传播

和原生 DOM 事件不一样，组件触发的事件没有冒泡机制。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个全局状态管理方案。
