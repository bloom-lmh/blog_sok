# 插槽

[[toc]]

## 默认插槽

当一个组件只有一个插槽的时候，这个插槽就是默认插槽，也就是插槽的默认出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染
举例来说，这里有一个 `<FancyButton>` 组件，可以像这样使用：

```vue
<FancyButton>
  Click me! <!-- 插槽内容 -->
</FancyButton>
```

而 `<FancyButton>` 的模板是这样的：

```vue
<button class="fancy-btn">
  <slot></slot> <!-- 插槽出口 -->
</button>
```

`<slot>` 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。

![默认插槽](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250913211740468.png)

## 渲染作用域

插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：

```vue
<span>{{ message }}</span>
<FancyButton>{{ message }}</FancyButton>
```

这里的两个 {{ message }} 插值表达式渲染的内容都是一样的。插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的**词法作用域规则**是一致的。换言之：

> 父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。

::: tip 关于词法作用域的补充
函数只能访问它定义时所在作用域的变量
:::

## 为插槽提供默认内容

在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 `<SubmitButton>` 组件,
如果我们想在父组件没有提供任何插槽内容时在 `<button>` 内渲染“Submit”，只需要将“Submit”写在 `<slot>` 标签之间来作为默认内容：

```vue
<button type="submit">
  <slot>
    Submit <!-- 默认内容 -->
  </slot>
</button>
```

现在，当我们在父组件中使用 `<SubmitButton>`且没有提供任何插槽内容时：

```vue
<SubmitButton />
```

Submit 将会被作为默认内容渲染：

```vue
<button type="submit">Submit</button>
```

但如果我们提供了插槽内容：

```vue
<SubmitButton>Save</SubmitButton>
```

那么被显式提供的内容会取代默认内容：

```vue
<button type="submit">Save</button>
```

## 具名插槽

一个组件可以具有多个插槽，这时候需要为插槽定义名字，这样子组件才知道把父组件传来的组件片段放在哪个地方

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 `<template>` 元素，并将目标插槽的名字传给该指令：

```html
<BaseLayout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <!-- 隐式的默认插槽 -->
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <!-- 简写形式 -->
  <template #footer>
    <p>Here's some contact info</p>
  </template>
</BaseLayout>
```

## 条件插槽

有时你需要根据内容是否被传入了插槽来渲染某些内容。你可以结合使用 `$slots` 属性与 `v-if` 来实现。
在下面的示例中，我们定义了一个卡片组件，它拥有三个条件插槽：header、footer 和 default。 当 header、footer 或 default 的内容存在时，我们希望包装它以提供额外的样式：

```html
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>

    <div v-if="$slots.default" class="card-content">
      <slot />
    </div>

    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>
```

## 动态插槽名

动态指令参数在 v-slot 上也是有效的，即可以定义下面这样的动态插槽名：

```html
<base-layout>
  <template v-slot:[dynamicSlotName]> ... </template>

  <!-- 缩写为 -->
  <template #[dynamicSlotName]> ... </template>
</base-layout>
```

## 作用域插槽

所谓的作用域插槽就是在插入的时候为插入的组件提供数据

### 默认作用域插槽

当一个组件插入默认插槽时，可以通过在默认插槽上提供 props 进而为插入的组件提供数据。
当父组件使用子组件的时候，只需要使用`v-slot="对象"` 来接受 props

::: code-group

```html [MyComponent(子组件)]
<!-- <MyComponent> 的模板 -->
<div>
  <!-- 在默认插槽上提供props -->
  <slot :text="greetingMessage" :count="1"></slot>
</div>
```

```html [父组件提供片段]
<!-- slotProps就是包含对应slot提供的props的对象 -->
<MyComponent v-slot="slotProps"> {{ slotProps.text }} {{ slotProps.count }} </MyComponent>
```

:::
![默认作用域插槽](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250913213452507.png)

### 具名作用域插槽

具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：`v-slot:name="slotProps"`。当使用缩写时是这样：

```html
<MyComponent>
  <template #header="headerProps"> {{ headerProps }} </template>

  <template #default="defaultProps"> {{ defaultProps }} </template>

  <template #footer="footerProps"> {{ footerProps }} </template>
</MyComponent>
```

向具名插槽中传入 props：

```html
<slot name="header" message="hello"></slot>
```

::: warning 注意 name 属性
注意插槽上的 name 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 headerProps 的结果是 `{ message: 'hello' }`。
:::

### 同时使用默认和具名作用域插槽

如果你同时使用了具名插槽与默认插槽，则需要为默认插槽使用显式的 `<template>` 标签。尝试直接为组件添加 v-slot 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：

```html
<!-- <MyComponent> template -->
<div>
  <slot :message="hello"></slot>
  <slot name="footer" />
</div>
```

为默认插槽使用显式的 `<template>` 标签有助于更清晰地指出 message 属性在其他插槽中不可用：

```html
<MyComponent>
  <!-- 使用显式的默认插槽 -->
  <template #default="{ message }">
    <p>{{ message }}</p>
  </template>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</MyComponent>
```

### :star: 最佳实践

你可能想问什么样的场景才适合用到作用域插槽，这里我们来看一个 `<FancyList>` 组件的例子。它会渲染一个列表，并同时会封装一些加载远端数据的逻辑、使用数据进行列表渲染、或者是像分页或无限滚动这样更进阶的功能。然而我们希望它能够保留足够的灵活性，将对单个列表元素内容和样式的控制权留给使用它的父组件。我们期望的用法可能是这样的：

```html
<FancyList :api-url="url" :per-page="10">
  <template #item="{ body, username, likes }">
    <div class="item">
      <p>{{ body }}</p>
      <p>by {{ username }} | {{ likes }} likes</p>
    </div>
  </template>
</FancyList>
```

在 `<FancyList>` 之中，我们可以多次渲染 `<slot>` 并每次都提供不同的数据 (注意我们这里使用了 v-bind 来传递插槽的 props)：

```html
<ul>
  <li v-for="item in items">
    <slot name="item" v-bind="item"></slot>
  </li>
</ul>
```

::: tip 作用域插槽的最佳实践总结
子组件提供数据，父组件决定样式
:::

### 无渲染组件(逻辑组件)

上面的 `<FancyList>` 案例同时封装了可重用的逻辑 (数据获取、分页等) 和视图输出，但也将部分视图输出通过作用域插槽交给了消费者组件来管理。
如果我们将这个概念拓展一下，可以想象的是，一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。
这里有一个无渲染组件的例子，一个封装了追踪当前鼠标位置逻辑的组件：

```vue
<MouseTracker v-slot="{ x, y }">
  Mouse is at: {{ x }}, {{ y }}
</MouseTracker>
```

::: tip 理解无渲染组件
所谓的无渲染组件就是指提供逻辑不提供视图的组件，即视图样式交给消费者组件来进行管理。
虽然这个模式很有趣，但大部分能用无渲染组件实现的功能都可以通过**组合式 API** 以另一种更高效的方式实现
:::
