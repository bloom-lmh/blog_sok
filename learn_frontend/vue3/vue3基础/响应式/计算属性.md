# 计算属性

[[toc]]

## 计算属性与 ref

计算属性是用来处理模板表达式过于复杂的问题。调用时需要传入一个 getter 函数，这个函数会返回一个值，这个值会根据依赖的响应式数据自动更新。计算属性的值本质上也是一个 ref 对象

```js
const count = ref(0);
const doubleCount = computed(() => count.value * 2);
```

## 计算属性缓存和方法

一个计算属性仅会在其响应式依赖更新时才重新计算。相比之下，方法调用总是会在重渲染发生时再次执行函数。
比如下面的代码 `getUserCount`调用两次，而 `userCount` 所对应的计算属性函数仅会调用一次

```vue {5-6,14-16}
<template>
  <div>
    {{ userCount }}
    {{ userCount }}
    {{ getUserCount() }}
    {{ getUserCount() }}
  </div>
</template>
<script setup>
import { isProxy, reactive, ref, computed } from 'vue';
const userCount = computed(() => {
  return userList.value.length;
});
function getUserCount() {
  return userList.value.length;
}
</script>
```

这也解释了为什么下面的计算属性永远不会更新，因为`Date.now()` 并不是一个响应式依赖：

```js
const now = computed(() => Date.now());
```

::: tip 为什么需要缓存
想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要。
:::
