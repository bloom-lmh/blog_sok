# 数据处理

[[toc]]

## 配置概览

数据处理有以下几个方法：
::: code-group

```js [通用配置]
// 【高级】请求数据转换器（仅适用于PUT/POST/PATCH/DELETE）
// 最后一个函数必须返回字符串/Buffer/FormData/Stream等
transformRequest: [function (data, headers) {
  // 可在此处修改请求数据或headers
  return data;
}],
// 【高级】响应数据转换器（在then/catch前处理数据）
transformResponse: [function (data) {
  // 可在此处转换响应数据
  return data;
}],

// 【重要】响应数据类型（json/text/stream等）
responseType: 'json',


```

```js [node专用]
// 【Node专用】响应数据的编码方式
responseEncoding: 'utf8',
```

:::

## transformRequest/Response

### 发请求前修改数据-transformRequest

transformRequest 可以接受一个数组，每个函数都会在发请求前被调用，可以对请求数据进行处理。

```js
axios.create({
  transformRequest: [
    function (data, headers) {
      // 第一个转换函数：添加公共请求头
      headers['X-Request-From'] = 'WebApp';
      return data;
    },
    function (data, headers) {
      // 第二个转换函数：转换数据为JSON格式
      headers['Content-Type'] = 'application/json';
      if (typeof data === 'object') {
        return JSON.stringify(data);
      }
      return data;
    },
    function (data, headers) {
      // 第三个转换函数：加密敏感数据
      if (data && data.password) {
        data.password = encrypt(data.password);
        return data;
      }
      return data;
    },
  ],
});
```

### 收到响应后处理数据-transformResponse

transformResponse 可以接受一个数组，每个函数都会在收到响应后被调用，可以对响应数据进行处理。

```js
axios.create({
  transformResponse: [
    function (data) {
      // 第一个转换函数：尝试解析JSON
      try {
        return JSON.parse(data);
      } catch (e) {
        return data;
      }
    },
    function (data) {
      // 第二个转换函数：统一数据格式
      if (data && data.code === 0) {
        return data.data;
      }
      return data;
    },
    function (data) {
      // 第三个转换函数：转换日期字符串
      if (data && data.createTime) {
        data.createTime = new Date(data.createTime);
      }
      return data;
    },
  ],
});
```

### transformRequest/Response 的局限性

1. 只有 PUT、POST、PATCH 请求才会执行 transformRequest，GET 请求即使配置了也不会执行

```js
axios.get('/api/data', {
  transformRequest: [
    function (data) {
      // ❌ 这个不会被执行
      return data;
    },
  ],
});
```

2. 默认转换器会被覆盖

```js
// ❌ 错误做法：完全覆盖默认转换器
axios.create({
  transformRequest: [
    function (data) {
      // 缺少默认的 JSON 序列化逻辑
      return data; // 对象不会自动转为 JSON 字符串
    },
  ],
});

// ✅ 正确做法：保留默认转换器
axios.create({
  transformRequest: [
    function (data) {
      // 自定义处理
      return data;
    },
    ...axios.defaults.transformRequest, // 保留默认转换器
  ],
});
```

3. 异步操作的限制

```js
// ❌ transformRequest 不支持 async/await
transformRequest: [async function(data) {
  const processedData = await processData(data);
  return processedData; // 可能不会按预期工作
}]

// ✅ 应该在拦截器中处理异步操作
requestInterceptor: async function(config) {
  config.data = await processData(config.data);
  return config;
}
```

4. 返回 undefined 会中断流程

```js
const instance = axios.create({
  transformRequest: [
    function (data, headers) {
      console.log('转换函数 1 执行');
      // 某种条件下返回 undefined
      if (data && data.skipTransform) {
        console.log('中断 transformRequest 链');
        return undefined; // 中断后续转换函数
      }
      return data;
    },
    function (data, headers) {
      console.log('转换函数 2 执行'); // 这个不会被执行
      headers['X-Processed'] = 'true';
      return data;
    },
    function (data, headers) {
      console.log('转换函数 3 执行'); // 这个也不会被执行
      return JSON.stringify(data);
    },
  ],
});

// 使用示例
instance.post('/api/data', { skipTransform: true, name: 'test' });
// 输出：
// 转换函数 1 执行
// 中断 transformRequest 链
```

### transformRequest/Response 和拦截器的区别

执行顺序上：transformRequest → 请求拦截器 → 发送请求 → 响应拦截器 → transformResponse
功能定位上：

1. 数据转换器
   - 专注于数据格式转换 ​​
   - 主要用于请求/响应数据的序列化/反序列化
   - 通常不处理错误或执行条件逻辑
2. 拦截器
   - 功能更全面，可以处理各种逻辑
   - 可以中断请求/响应流程
   - 可以执行异步操作
   - 更适合处理认证、错误处理等业务逻辑

## 指定响应数据格式-responseType

responseType 是 Axios 请求配置中的一个重要选项，用于指定服务器响应数据的预期类型，配置了该选项后 axios 会进行如下处理：

- 定义如何解析从服务器接收的原始二进制数据
- 自动将响应数据转换为指定格式
- 确保正确处理各种类型的响应内容

下面为使用示例：

::: code-group

```js [获取JSON数据(默认)]
axios
  .get('/api/user', {
    responseType: 'json', // 可省略，因为这是默认值
  })
  .then((response) => {
    console.log(response.data); // 自动解析为JavaScript对象
  });
```

```js [下载二进制文件]
// 根据文件扩展名动态设置
function downloadFile(url, filename) {
  const extension = filename.split('.').pop().toLowerCase();

  let responseType = 'blob';
  let mimeType = 'application/octet-stream';

  switch (extension) {
    case 'pdf':
      mimeType = 'application/pdf';
      break;
    case 'jpg':
    case 'jpeg':
      mimeType = 'image/jpeg';
      break;
    case 'png':
      mimeType = 'image/png';
      break;
    case 'txt':
      responseType = 'text';
      mimeType = 'text/plain';
      break;
  }

  return axios({
    method: 'get',
    url: url,
    responseType: responseType,
    transformResponse: [
      function (data) {
        if (responseType === 'blob') {
          return new Blob([data], { type: mimeType });
        }
        return data;
      },
    ],
  });
}

// 使用示例
downloadFile('/api/files/document.pdf', 'document.pdf').then((response) => {
  // 处理下载的文件
});
```

```js [获取XML数据]
axios({
  method: 'get',
  url: '/api/data.xml',
  responseType: 'document',
}).then((response) => {
  // response.data 是 XML Document 对象
  const xmlDoc = response.data;
  const title = xmlDoc.getElementsByTagName('title')[0].textContent;
  console.log('XML 标题:', title);
});
```

```js [获取文本数据]
axios({
  method: 'get',
  url: '/api/data.txt',
  responseType: 'text',
}).then((response) => {
  // response.data 是字符串
  console.log('文本内容:', response.data);
});
```

```js [获取ArrayBuffer数据]
axios({
  method: 'get',
  url: '/api/binary/data',
  responseType: 'arraybuffer',
}).then((response) => {
  // response.data 是 ArrayBuffer
  const uint8Array = new Uint8Array(response.data);
  console.log('二进制数据长度:', uint8Array.length);
});
```

```js [获取Stream数据]
// stream - 用于流式数据处理（Node.js 环境）
axios({
  method: 'get',
  url: '/api/large-data',
  responseType: 'stream',
}).then((response) => {
  // response.data 是可读流
  const stream = response.data;

  stream.on('data', (chunk) => {
    console.log('接收到数据块:', chunk.length, 'bytes');
  });

  stream.on('end', () => {
    console.log('数据接收完成');
  });
});
```

:::

::: tip 关于 blob 和 ArrayBuffer
blob 和 arrayBuffer 都是两个处理二进制数据的对象，它们之间的区别在于：
blob:

- 按 MIME 类型处理二进制数据
- 包含数据内容 + 类型信息
- 浏览器知道如何根据 type 来处理这个数据
- 适合文件操作、网络传输

ArrayBuffer:

- 非常底层，纯粹的二进制数据，没有类型信息
- 就是一串字节，需要通过视图来解释
- 适合数值计算、底层数据操作

:::

## 响应数据的编码方式-responseEncoding

responseEncoding 用于指定响应数据的字符编码格式，主要在 Node.js 环境中使用。

```js
// 基本用法
axios.get('/api/data', {
  responseEncoding: 'utf8', // 默认值
});

// 其他编码格式
axios.get('/api/data', {
  responseEncoding: 'latin1', // 或 'binary'
});

axios.get('/api/data', {
  responseEncoding: 'base64',
});
```

::: tip 常用的编码格式

```bash
'utf8', // UTF-8 (默认)
'utf-8', // UTF-8 别名
'ascii', // ASCII
'binary', // 二进制
'latin1', // Latin-1
'base64', // Base64
'hex', // 十六进制
'ucs2', // UCS-2
'ucs-2', // UCS-2 别名
'utf16le', // UTF-16 Little Endian
'utf-16le' // UTF-16 Little Endian 别名
```

:::
