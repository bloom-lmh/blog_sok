# 进度监控

[[toc]]

## 配置概览

与进度监控相关的配置项有：

```js
// 【浏览器专用】上传进度回调
onUploadProgress: function (progressEvent) {
  // 处理上传进度事件
},
// 【浏览器专用】下载进度回调
onDownloadProgress: function (progressEvent) {
  // 处理下载进度事件
},
```

## 上传下载进度回调

### 基本使用

```js
// 上传进度监听
axios.post('/api/upload', formData, {
  onUploadProgress: function (progressEvent) {
    // progressEvent 包含进度信息
    console.log('上传进度:', progressEvent);
  },
});

// 下载进度监听
axios.get('/api/download/file.zip', {
  responseType: 'blob',
  onDownloadProgress: function (progressEvent) {
    // progressEvent 包含进度信息
    console.log('下载进度:', progressEvent);
  },
});
```

### progressEvent 对象属性

```js
axios.post('/api/upload', formData, {
  onUploadProgress: function (progressEvent) {
    console.log({
      loaded: progressEvent.loaded, // 已传输的字节数
      total: progressEvent.total, // 总字节数
      lengthComputable: progressEvent.lengthComputable, // 是否可计算进度
      progress: progressEvent.loaded / progressEvent.total, // 进度比例
    });
  },
});
```

### 应用示例

文件上传示例：

```js
// HTML
// <div id="progress-bar" style="width: 0%; height: 20px; background: blue;"></div>
// <div id="progress-text">0%</div>

function uploadFile(file) {
  const formData = new FormData();
  formData.append('file', file);

  return axios.post('/api/upload', formData, {
    onUploadProgress: function (progressEvent) {
      if (progressEvent.lengthComputable) {
        const percentCompleted = Math.round(
          (progressEvent.loaded * 100) / progressEvent.total
        );

        // 更新进度条
        document.getElementById('progress-bar').style.width =
          percentCompleted + '%';
        document.getElementById('progress-text').textContent =
          percentCompleted + '%';

        console.log(`上传进度: ${percentCompleted}%`);
      }
    },
  });
}

// 使用示例
const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', function (event) {
  const file = event.target.files[0];
  uploadFile(file)
    .then((response) => {
      console.log('上传成功:', response.data);
    })
    .catch((error) => {
      console.error('上传失败:', error);
    });
});
```

文件下载示例：

```js
// HTML
// <button onclick="downloadFile()">下载大文件</button>
// <div id="download-progress" style="display: none;">
//   <div id="download-bar" style="width: 0%; height: 20px; background: green;"></div>
//   <div id="download-text">0%</div>
// </div>

async function downloadFile() {
  const progressDiv = document.getElementById('download-progress');
  const progressBar = document.getElementById('download-bar');
  const progressText = document.getElementById('download-text');

  progressDiv.style.display = 'block';

  try {
    const response = await axios({
      method: 'get',
      url: '/api/download/large-file.zip',
      responseType: 'blob',
      onDownloadProgress: function (progressEvent) {
        if (progressEvent.lengthComputable) {
          const percentCompleted = Math.round(
            (progressEvent.loaded * 100) / progressEvent.total
          );

          progressBar.style.width = percentCompleted + '%';
          progressText.textContent = `${percentCompleted}% (${formatBytes(
            progressEvent.loaded
          )} / ${formatBytes(progressEvent.total)})`;

          console.log(`下载进度: ${percentCompleted}%`);
        } else {
          // 无法计算总大小时的处理
          progressText.textContent = `已下载: ${formatBytes(
            progressEvent.loaded
          )}`;
        }
      },
    });

    // 下载完成后保存文件
    const url = window.URL.createObjectURL(new Blob([response.data]));
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', 'large-file.zip');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);

    progressDiv.style.display = 'none';
  } catch (error) {
    console.error('下载失败:', error);
    progressDiv.style.display = 'none';
  }
}

// 格式化字节大小
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
```
