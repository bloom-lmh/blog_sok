# 请求拦链

[[toc]]

## 拦截器的基本使用

使用你可以在请求或响应被 `then` 或 `catch` 处理之前拦截它们。拦截器本质就是职责链模式的一种实现。

### 添加请求/响应拦截器

```js
// Add a request interceptor
axios.interceptors.request.use(
  function (config) {
    // Do something before request is sent
    return config;
  },
  function (error) {
    // Do something with request error
    return Promise.reject(error);
  }
);

// Add a response interceptor
axios.interceptors.response.use(
  function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
  },
  function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  }
);
```

### 移除请求/响应拦截器

```js
const myInterceptor = axios.interceptors.request.use(function (config) {
  // Do something before request is sent
  return config;
});

// Sometime later...
axios.interceptors.request.eject(myInterceptor);
```

## 拦截器链

### 设置多个拦截器

拦截器可以设置多个，并且全局拦截器和实例拦截器可以一同工作，如下所示：

```js
// 全局响应拦截器
axios.interceptors.response.use((response) => {
  console.log('全局响应拦截器1');
  response.data.globalMark = true;
  return response;
});
axios.interceptors.request.use((config) => {
  console.log('全局响应拦截器1');
  return config;
});
// 实例响应拦截器
instance.interceptors.response.use((response) => {
  console.log('实例响应拦截器');
  response.data.instanceMark = true;
  return response;
});
```

### 多个拦截器的执行顺序

不同类型混合时：全局请求拦截器 → 实例请求拦截器 → 发送请求接收响应 → 实例响应拦截器 → 全局响应拦截器

```js
// 全局拦截器
axios.interceptors.request.use((config) => {
  console.log('🌍 全局请求拦截器');
  return config;
});

axios.interceptors.response.use((response) => {
  console.log('🌍 全局响应拦截器');
  return response;
});

// 实例拦截器
const api = axios.create();

api.interceptors.request.use((config) => {
  console.log('📱 实例请求拦截器');
  return config;
});

api.interceptors.response.use((response) => {
  console.log('📱 实例响应拦截器');
  return response;
});

// 发起请求
api.get('/test');

// 输出顺序：
// 🌍 全局请求拦截器
// 📱 实例请求拦截器
// 📱 实例响应拦截器
// 🌍 全局响应拦截器
```

同一类型：

```js
const api = axios.create();

// 添加多个请求拦截器
api.interceptors.request.use((config) => {
  console.log('🔧 请求拦截器A');
  config.headers['X-A'] = 'A';
  return config;
});

api.interceptors.request.use((config) => {
  console.log('🔧 请求拦截器B');
  config.headers['X-B'] = 'B';
  return config;
});

api.interceptors.request.use((config) => {
  console.log('🔧 请求拦截器C');
  config.headers['X-C'] = 'C';
  return config;
});

// 添加多个响应拦截器
api.interceptors.response.use((response) => {
  console.log('✅ 响应拦截器X');
  return response;
});

api.interceptors.response.use((response) => {
  console.log('✅ 响应拦截器Y');
  return response;
});

api.interceptors.response.use((response) => {
  console.log('✅ 响应拦截器Z');
  return response;
});

api.get('/test');

// 完整输出顺序：
// 🔧 请求拦截器A
// 🔧 请求拦截器B
// 🔧 请求拦截器C
// ✅ 响应拦截器Z
// ✅ 响应拦截器Y
// ✅ 响应拦截器X
```

## 拦截器、数据转换和自定义状态的执行顺序

当拦截器、数据转换和自定义状态在一起时，它们的执行顺序如下：

```js
// 1. 全局配置
axios.defaults.validateStatus = (status) => {
  console.log(`🔍 validateStatus: ${status}`);
  return status < 500; // 4xx 以下视为成功
};

// 2. 全局请求拦截器
axios.interceptors.request.use((config) => {
  console.log('🌍 全局请求拦截器');
  return config;
});

// 3. 全局响应拦截器
axios.interceptors.response.use(
  (response) => {
    console.log('🌍 全局响应拦截器');
    return response;
  },
  (error) => {
    console.log('🌍 全局错误拦截器');
    return Promise.reject(error);
  }
);

// 4. 创建实例
const api = axios.create({
  transformRequest: [
    (data) => {
      console.log('🔄 请求转换1');
      return data;
    },
    (data) => {
      console.log('🔄 请求转换2');
      return JSON.stringify(data);
    },
  ],
  transformResponse: [
    (data) => {
      console.log('🔄 响应转换1');
      return data;
    },
    (data) => {
      console.log('🔄 响应转换2');
      try {
        return JSON.parse(data);
      } catch {
        return data;
      }
    },
  ],
});

// 5. 实例请求拦截器
api.interceptors.request.use((config) => {
  console.log('📱 实例请求拦截器');
  return config;
});

// 6. 实例响应拦截器
api.interceptors.response.use(
  (response) => {
    console.log('📱 实例响应拦截器');
    return response;
  },
  (error) => {
    console.log('📱 实例错误拦截器');
    return Promise.reject(error);
  }
);

// 7. 发起请求
api
  .post('/api/users', { name: 'John' })
  .then((response) => {
    console.log('✅ 最终响应');
  })
  .catch((error) => {
    console.log('❌ 最终错误');
  });
```

执行结果如下：
::: code-group

```bash [成功响应情况]
🌍 全局请求拦截器
📱 实例请求拦截器
🔄 请求转换1
🔄 请求转换2
🔍 validateStatus: 200
🔄 响应转换1
🔄 响应转换2
📱 实例响应拦截器
🌍 全局响应拦截器
✅ 最终响应
```

```bash [404 错误情况]
🌍 全局请求拦截器
📱 实例请求拦截器
🔄 请求转换1
🔄 请求转换2
🔍 validateStatus: 404
🔄 响应转换1
🔄 响应转换2
📱 实例响应拦截器
🌍 全局响应拦截器
✅ 最终响应 (因为 validateStatus 返回 true)
```

```bash [服务器错误情况]
🌍 全局请求拦截器
📱 实例请求拦截器
🔄 请求转换1
🔄 请求转换2
🔍 validateStatus: 500
📱 实例错误拦截器
🌍 全局错误拦截器
❌ 最终错误
```

:::

## 最佳实践

拦截器通常用来做如下工作：

### 统一身份认证

```js
// 添加全局Token
axios.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

作用 ​：自动为所有请求添加 JWT 等认证信息
场景 ​：用户登录状态维护、API 权限控制

### 全局错误处理

```js
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response.status === 401) {
      router.push('/login'); // 跳转到登录页
    }
    return Promise.reject(error);
  }
);
```

作用 ​：集中处理 HTTP 错误码（如 401/404/500）
场景 ​：统一弹窗提示、登录过期跳转

### 请求防抖

```js
const pendingRequests = new Map();
axios.interceptors.request.use((config) => {
  const key = `${config.method}-${config.url}`;
  if (pendingRequests.has(key)) {
    pendingRequests.get(key).abort(); // 取消重复请求
  }
  const controller = new AbortController();
  config.signal = controller.signal;
  pendingRequests.set(key, controller);
  return config;
});

axios.interceptors.response.use((response) => {
  const key = `${response.config.method}-${response.config.url}`;
  pendingRequests.delete(key);
  return response;
});
```

作用 ​：防止重复提交
场景 ​：表单提交、高频查询
