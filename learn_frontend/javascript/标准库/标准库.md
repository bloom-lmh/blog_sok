# 标准库

[[toc]]

js 中有很多的标准库

## 集合-set

### 集合与数组

集合就是一组值，与数组类似，但是又与数组不同，不同点如下：

- 集合不允许有重复的值，而数组中可以
- 集合没有索引和顺序，而数组有
- Set 的 `has()` 方法（判断元素是否存在）的时间复杂度为 `O(1)`，比数组的 `includes()（O(n)）`更高效，适合频繁查找的场景。

### 创建集合

创建集合可以传入一个可迭代对象作为初始值

```js
let arr = [1, 2, 3];
let s = new Set(arr);
console.log(s.size); // 3
```

::: tip 集合中存储特殊值
Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

- `+0` 与 `-0` 在存储判断唯一性的时候是恒等的，所以不重复；
- `undefined` 与 `undefined` 是恒等的，所以不重复；
- `NaN` 与 `NaN` 是不恒等的（`NaN !== NaN`），但是在 Set 中只能存一个，不重复。

:::

### 集合的增删改查操作

```js
s.add(4).add(5); // 添加元素可以链式调用
s.delete(2); // 删除元素 删除成功返回true 删除失败返回false
console.log(s.has(2)); // 判断元素是否存在，返回boolean
console.log(s.size); // 获取set集合大小
s.clear(); // 清空所有元素
```

::: tip 集合元素的比较
集合中查找元素是按照`===`来进行比较的。所以如果集合中存储了对象，那么想要操作这个对象必须使用这个对象的引用。

```js
let s2 = new Set();
let o = { name: "John", age: 30 };
s2.add(o);
s2.delete({ name: "John", age: 30 }); // 无法删除，因为Set集合只存储对象引用，而不是对象本身
s2.add(o);
s2.delete(o); // 删除成功
```

:::

### 遍历集合

set 集合是可以迭代的，所以可以使用 forof 和扩展运算符

```js
for (const elem of s1) {
  console.log(elem);
}
// entrie() 返回一个条目数组
for (const [elem1, elem2] of s1.entries()) {
  console.log(elem1, elem2);
}
```

::: tip js 中的条目
js 的条目是指只有两个元素的数组，比如`[1, 2]`就是条目。
:::

并且 set 集合也有 forEach 方法,但是由于它没有索引，所以它的第二个值也是和第一个值相同的元素

```js
s1.forEach((item1, item2) => {
  console.log(item1, item2);
});
```

values 方法可以返回一个可迭代对象，所以可以像遍历迭代器对象那些进行遍历

```js
const iterator = s1.values(); // 获取数组的迭代器

let result = iterator.next();
while (!result.done) {
  console.log(result.value); // 依次输出: 'a', 'b'
  result = iterator.next();
}
```

::: tip 集合的有序性
JavaScript 的 Set 类会记住元素的插入顺序，而且始终按该顺序迭代集合
:::

## 映射-map

### 映射与对象

在没有映射之前，JavaScript 中只能使用对象来实现键值对的存储。但是对象作为映射有一些缺点，比如：

- 对象的键必须是字符串，不能是其他类型，而且不能用其他类型的值作为键。
- 对象必须继承 `toString()`等方法，导致映射存在一些不需要的键值对。所以消耗内存比 Map 多

### 创建映射

创建映射的时候可以使用条目数组来进行初始化

```js
// 使用条目进行初始化
let m = new Map([
  ["name1", "value1"],
  ["name2", "value2"],
]);
// 当然也可以将对象转为条目
let obj = {
  name2: "value2",
};
let m2 = new Map(Object.entries(obj));
console.log(m2); // Map(1) { "name2" => "value2" }
```

::: tip 键的唯一性
映射的键是唯一的，所以不能有重复的键。如果在创建时重复后面的值会覆盖前面的值

```js
let m1 = new Map([
  ["name1", "value1"],
  ["name1", "value2"],
]);
console.log(m1.get("name1")); // "value2"
```

:::

### 映射的增删改查操作

```js {5}
let m = new Map([["name1", "value1"]]);
console.log(m); // Map(1) { "name1" => "value1" }
m.set("name2", "value2").set("name3", "value3"); // 添加映射，允许链式调用
console.log(m); // Map(3) { "name1" => "value1", "name2" => "value2", "name3" => "value3" }
m.set("name1", "new value1"); // 当设置已存在的键时，会更新键为name1的映射
console.log(m); // Map(3) { "name1" => "new value1", "name2" => "value2", "name3" => "value3" }
m.delete("name2"); // 删除键为name2的映射
console.log(m); // Map(2) { "name1" => "new value1", "name3" => "value3" }
console.log(m.size); // 2
console.log(m.has("name1")); // true
console.log(m.get("name1")); // "new value1"
```

::: tip 映射的键的比较
映射的键的比较是按照`===`来进行比较的，所以如果两个键值对的键是同一个对象，那么它们的键值对是相等的。
:::

### 映射向数组转换

```js
console.log(m.keys()); // ["name1", "name3"] 所有的键组成的数组
console.log(m.values()); // ["new value1", "value3"] 所有的值组成的数组
console.log(m.entries()); // [["name1", "new value1"], ["name3", "value3"]] 所有的键值对组成的数组
```

### 遍历映射

映射也是可迭代对象，每一个元素都是一个条目数组，可以使用 forof 和扩展运算符进行遍历

```js
// 遍历键值对
for (let [key, value] of m.entries()) {
  console.log(key, value);
}
// 遍历键值对
for (let [key, value] of m) {
  console.log(key, value);
}
// 只遍历键集合
for (let key of m.keys()) {
  console.log(key);
}
// 只遍历值集合
for (let value of m.values()) {
  console.log(value);
}
// 遍历键值对，并对每个键值对执行回调函数
m.forEach((value, key, map) => {
  console.log(key, value, map);
});
```

## weakMap/weakSet

## 定型数组

## 时间与日期

## Json 序列化与解析

## URL API

## 定时器
