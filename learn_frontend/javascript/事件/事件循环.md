# 事件循环

[[toc]]

练习网站：https://www.jsv9000.app/

## 事件循环中的数据结构

- 执行栈：执行栈是事件循环的核心，它存储着当前正在执行的任务信息，包括同步任务、宏任务和微任务。执行栈由
- 宏任务队列：宏任务队列里面存储着将要执行的宏任务，每次事件循环的主任务阶段，只执行一个宏任务。
- 微任务队列：微任务队列里面存储着将要执行的微任务，每次事件循环的主任务阶段，执行完所有微任务后，才会执行下一个宏任务。
- 动画帧任务队列：动画帧任务队列里面存储着将要执行的动画帧任务，每次事件循环的主任务阶段，执行完所有动画帧任务后，才会执行下一个宏任务。

![事件循环中的数据结构](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250626112050041.png)

## 事件循环中的各类任务

### 同步任务

特点 ​：立即执行，阻塞主线程，不经过任何任务队列。
示例 ​：

```javascript
console.log('同步代码');
const a = 1 + 1; // 同步表达式
```

执行时机 ​：脚本加载时直接放入执行栈执行，在此期间遇到的宏任务会入宏任务队列，微任务会入微任务队列，执行栈清空时是事件循环的触发起点 ​（不属于循环迭代）。同步代码执行完毕的空档期可以看作第 0 个宏任务执行（没有任何代码）

### 宏任务

特点 ​：由宿主环境（浏览器/Node.js）调度，每个事件循环周期执行一个宏任务。
常见的宏任务有：`setTimeout`、`setInterval`、`I/O`、`UI 渲染`、`DOM回调`。
执行时机 ​：每次事件循环的主任务阶段 ​（在微任务之后）。

### 微任务

特点 ​：优先级高于宏任务，必须在当前宏任务结束后立即全部执行 ​（包括嵌套微任务）。
常见的微任务有：`Promise.then / catch / finally`、`MutationObserver`。
执行时机 ​：当前宏任务执行完毕后，​ 清空微任务队列才会继续事件循环。

::: warning 注意 Promise 的执行器中的任务
创建 promise 时的执行器函数是同步的执行的,只有`Promise.then / catch / finally`的回调才是异步的
:::

### 动画帧任务

特点 ​：专为浏览器动画优化，与渲染周期同步。
API​：`requestAnimationFrame(callback)`
执行时机 ​：

- 在微任务队列清空后、浏览器渲染前执行。
- 默认与屏幕刷新率同步（通常 60fps）。

## 事件循环执行规则

### 同步代码执行阶段（阶段 1）

同步代码直接压入调用栈执行（不经过任何队列），遇到异步操作时，宏任务回调加入宏任务队列，微任务回调加入微任务队列。只有调用栈完全清空后，才会启动事件循环

### 事件循环阶段（阶段 2）

当同步代码执行完毕即执行栈空闲后事件循环开始，执行过程中新产生的宏任务放入宏任务队列尾部，微任务放入微任务队列尾部。

- 宏任务执行阶段： 首先取出队首的宏任务到执行栈开始执行
- 微任务清空阶段：执行完宏任务后，如果微任务队列不为空，则依次将微任务队列中的微任务放入执行栈执行（包括嵌套微任务）
- 渲染相关阶段 ​：执行 requestAnimationFrame 回调（与屏幕刷新率同步），浏览器进行样式计算、布局、绘制等操作（约 60fps）
- 空闲阶段 ​：执行 requestIdleCallback 回调（当主线程空闲时）
- 然后进入下一轮事件循环

::: tip 总结
同步代码执行完->开启循环(执行队首宏任务，清空微任务)
:::

::: warning 注意 `Promise.then`

1. 创建 promise 时的执行器函数是同步的执行的
2. resolve 后,且 resolve 后的同步代码执行完毕后，才会把 then 方法的回调函数放到微队列当中(可以看 Promise 的源码部分)

:::
::: warning 注意定时器
对于定时器，首先会放到定时器模块，然后时间到了后再放入到宏队列中。也就是说还是要等主线程执行完成后才能执行。
:::

## 面试题

### Promise.then 的回调放入微队列的时机

```javascript
setTimeout(() => {
  new Promise(resolve => {
    console.log('1');
    resolve();
  }).then(() => {
    console.log('2');
  });
}, 0);
new Promise(resolve => {
  setTimeout(() => {
    console.log('3');
    resolve();
  }, 0);
  console.log('4');
}).then(() => {
  console.log('5');
});
console.log('6');
```

输出结果是：`4、6、1、2、3、5`
解析：

1. 同步执行：输出 4、6

![同步执行](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250626143326601.png)

2. 第一次循环：执行宏任务（最外层 setTimeout），并将 then 的回调放入微任务队列，输出 1、2

![第一次循环](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250626143902807.png)

3. 第二次循环：Promise 中的 setTimeout 调入执行栈，此时触发 resolve，then 函数的回调放入微任务队列，输出 3、5

![第二次循环](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20250626144958179.png)

### 关于定时器

对于定时器，首先会放到定时器模块，然后时间到了后再放入到宏队列中。也就是说还是要等主线程执行完成后才能执行。
比如下面的案例，我们设置了定时器 6 毫秒后执行，但是即便 6 毫秒时间到了，如果主线程代码没有执行完，定时器任务也不会执行。

```js
setTimeout(() => {
  console.log('定时器执行了');
}, 6);
for (let i = 0; i < 10000; i++) {
  console.log(i);
}
```

::: tip 定时器的最小时间
HTML 标准规定最小时间不能低于 4 毫秒，有些异步操作如 DOM 操作最低是 16 毫秒，总之把时间设置大些对性能更好。
:::

### resolve 相关问题

```js
new Promise((resolve, reject) => {
  resolve(1);

  new Promise((resolve, reject) => {
    resolve(2);
  }).then(data => {
    console.log(data); // 输出 2
  });
}).then(data => {
  console.log(data); // 输出 1
});

console.log(3); // 最先输出
```

输出结果是：`3、1、2`

::: tip 解析
resolve 后,且 resolve 后的同步代码执行完毕后，才会把 then 方法的回调函数放到微队列当中(可以看 Promise 的源码部分)
:::
