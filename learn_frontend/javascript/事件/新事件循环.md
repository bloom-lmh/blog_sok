# 事件循环

[[toc]]

现在已经不再称为宏任务了，而是有更多类型的任务

## 浏览器的进程模型

浏览器的最主要的进程有：

1. 浏览器进程：主要负责界⾯显示、⽤户交互、⼦进程管理等。浏览器进程内部会启动多个线程处理不同的任务。
2. ⽹络进程：负责加载⽹络资源。⽹络进程内部会启动多个线程来处理不同的⽹络任务。
3. 渲染进程（本节课重点讲解的进程）：渲染进程启动后，会开启⼀个渲染主线程，主线程负责执⾏ HTML、CSS、JS 代码。

::: tip 渲染进程与标签页
默认情况下，浏览器会为每个标签⻚开启⼀个新的渲染进程，以保证不同的标签⻚之间不相互影响。
:::

## 渲染主线程

渲染主线程是任务执行的场所，它负责处理 HTML、CSS、JS 代码，是浏览器中最繁忙的线程。

1. 在最开始的时候，渲染主线程会进⼊⼀个⽆限循环
2. 每⼀次循环会检查消息队列中是否有任务存在。如果有，就取出第⼀个任务执⾏，执⾏完⼀个后进⼊下⼀次循环；如果没有，则进⼊休眠状态。
3. 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务，拿取任务是依据任务的优先级进行的

## 消息队列的优先级及其任务

在事件循环中，其它线程与渲染主线程进行通信采用的就是消息队列的方式。对于渲染主线程来说，任务是没有优先级的，先进先出，但是任务队列（消息队列）是有优先级的，决定调度的先后顺序。

::: tip 进程通信的三种方式

1. 管道通信
2. 消息队列
3. 共享内存

:::

### 同步任务

同步任务包括：解析 HTML

### 微任务队列

存放任务 ​：

- `Promise.then` / `Promise.catch` / `Promise.finally` 回调。
- `MutationObserver` 回调。
- `queueMicrotask()`手动添加的任务。

任务处理线程：网络线程（Network Thread）
优先级 ​：最高，必须在当前 JS 任务结束后立即清空 ​（包括嵌套微任务）。

### 交互队列

存放任务 ​：用户触发的 `click、keydown、scroll` 等事件回调。
任务处理进程：浏览器进程（Browser Process），处理完成后放入交互队列
优先级 ​：高于普通宏任务，浏览器会优先调度。

### IO 回调队列

存放任务 ​：

- `fetch / XHR` 的响应回调。
- `FileReader` 等文件操作回调（浏览器中较少见，Node.js 中常见）。

任务处理线程：IO 线程（File IO Thread）/网络线程（Network Thread）
优先级 ​：高于定时器任务。

### 延时任务队列

存放任务 ​：`setTimeout`、`setInterval` 的回调。
任务处理线程：定时器线程（Timer Thread）处理完成后将回调函数包装成任务放入延时任务队列
优先级 ​：最低的宏任务队列。

### 渲染队列

存放任务：

- 样式计算（Recalculate Style）、布局（Layout）、绘制（Paint）指令生成。
- `requestAnimationFrame` 回调（在渲染前执行）。

::: tip 总结任务优先级
微任务队列 > 交互队列 > IO 回调队列 > 延迟队列 > 渲染流程
:::

## 事件循环步骤

### 阶段 1：解析 HTML 与构建 DOM/CSSOM

主线程解析 HTML

- 边下载边解析，生成 DOM 树。
- 遇到`<link>`或`<style>`时(预解析线程已经下载了 css 资源)，只需要同步解析 CSS 生成 CSSOM 树。

​ 遇到`<script>`标签 ​

- ​ 无 `async/defer`​：暂停 HTML 解析 → 下载并同步执行 JS​ → 继续解析。
- ​ 有 `async`​：异步下载，下载完成后立即执行 ​（可能中断 HTML 解析）。
- ​ 有 `defer`​：异步下载，在 DOM 解析完成后、`DOMContentLoaded` 前按顺序执行。

### 阶段 2：执行 JS 中的任务

同步任务:直接压入调用栈执行，阻塞后续代码：

```js
console.log('同步任务');
element.style.width = '100px'; // 同步修改样式
```

异步任务:主线程将任务交给对应线程（如定时器线程、网络线程）。其他线程处理完成后，将回调放入对应的任务队列。

1. 微任务（Microtask）

   - ​ 来源 ​：Promise.then、MutationObserver、queueMicrotask。
   - ​ 处理 ​：由 JS 引擎直接放入微任务队列，​ 在当前 JS 任务结束后立即清空 ​（包括嵌套微任务）。

2. 宏任务（Macrotask）​​：

| 任务类型     | 预处理线程 | 回调队列              | 示例                   |
| ------------ | ---------- | --------------------- | ---------------------- |
| 定时器任务   | 定时器线程 | 延迟队列(Timer)       | setTimeout/setInterval |
| 网络请求     | 网络线程   | IO 队列(或微任务队列) | fetch/XHR              |
| 用户交互事件 | 浏览器进程 | 交互队列(Input)       | click/scroll           |
| 文件读写     | IO 线程    | IO 队列               | FileReader             |

3. 渲染相关任务
   - `requestAnimationFrame`:回调函数放入渲染前队列，在下一帧渲染前执行。
   - 渲染流程（Layout/Paint）​​：
     - 由主线程同步执行样式计算、布局、生成绘制指令。
     - ​ 实际光栅化和合成由合成线程（Compositor Thread）异步处理。

### 阶段 3：事件循环调度

1. 检查调用栈 ​:若调用栈不为空，继续执行当前同步任务。调用栈为空时，进入事件循环下一步。
2. 清空微任务队列 ​:依次执行所有微任务（包括嵌套的微任务），直到队列清空。
3. 尝试渲染 ​:若有样式/布局变更或 `requestAnimationFrame` 回调，若无变更，跳过渲染。
   - 执行 `requestAnimationFrame` 回调
   - 同步执行 ​：样式计算 → 布局 → 绘制指令生成。
   - 将绘制指令交给合成线程光栅化并合成图像。
4. ​ 从宏任务队列取一个任务执行 ​：
   - ​ 按优先级顺序检查队列 ​：交互队列（click/scroll） → IO 队列（fetch/XHR） → 延迟队列（setTimeout）
   - 取出一个任务，压入调用栈执行，回到阶段 2。

::: tip 重拍重绘
重排重绘发生在第三步，浏览器渲染原理请见浏览器相关知识
:::

::: tip 总结事件循环
渲染主线程的职责就是处理任务，包括同步任务和异步任务，只不过异步任务会先交给其它对应线程先进行处理，处理完后再将回调封装为任务放入消息队列，渲染主线程再从消息队列中调度执行

:::
