# 类的本质

[[toc]]

## 类和构造函数

类的本质上就是构造函数，是构造函数的语法糖，比如下面的代码：

```js
class User {}
function Person() {}
// 类和构造函数都是函数类型
console.log(typeof Person); // function
console.log(typeof User); // function
// 类和函数的原型是Function
console.log(User.constructor); // [Function: Function]
console.log(Person.constructor); // [Function: Function]
```

可以看到 `Person` 和 `User` 都是函数类型，且都以 `Function` 为构造函数

## 类继承的本质

类和构造函数是实现 js 基于原型继承的桥梁。当创建对象的时候类和构造函数会将 `prototype` 属性设置作为新创建对象的原型。
比如：

1. 我通过 Parent 构造函数创建的对象就叫做 Parent 对象，是因为它继承了 `Parent.prototype`。
2. 我通过 User 类创建的对象就叫做 User 对象，是因为它继承了 `User.prototype`。

说白了，`prototype` 通过类和构造函数来外在表现自己，只要类和构造函数的原型指向了同一个对象，那么创建的对象就都有了相同的原型，就是同一类对象。
比如：当 `Parent.prototype` 和 `User.prototype` 指向同一个对象时,比如 Person 对象，那么创建的对象都有相同的原型，就是同一类对象。User 对象和 Parent 对象本质上就变成了 Person 对象。与 Parent 构造函数和 User 类没有关系。
在继承方面，`class` 本质上采用的是寄生式组合继承的语法糖，使用 `babel` 编译工具编译后发现 `class` 会转为寄生式组合方式

比如：
::: code-group

```js
function Parent(name) {
  this.name = name;
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child(name, age) {
  // 2. 复制父类属性，避免引用数据类型共享内存,等价于 this.name = name
  Parent.call(this, name);
  this.age = age;
}
// 1. Child继承自Parent的原型对象，使得Child也有Parent原型对象上的getName方法
Child.prototype = Object.create(Parent.prototype);
// 由于Child.prototype是parent对象，而parent对象的constructor属性指向Parent构造函数，所以要显示变更
Child.prototype.constructor = Child;

// 3. Child自身也可以添加方法
Child.prototype.getFriends = function () {
  return this.friends;
};
```

```js
// 等价于function Parent(name){}
class Parent {
  public name: string;
  constructor(name, age) {
    this.name = name;
  }
  // Parent.prototype.getName = function () {} 实际上挂载到类的原型上
  getName() {
    return this.name;
  }
}
// 等价于
// 1. Child.prototype = Object.create(Parent.prototype);
// 2. Child.prototype.constructor = Child;
// 这里Object.create创建了一个基于Parent.prototype原型的对象，所以我们姑且叫他为parent实例，Child实例的原型是Child.prototype，实际上是Parent就是Parent实例，所以Child对象就是属于Parent类
class Child extends Parent {
  constructor(name, age) {
    // 等价于Parent.call(this, name);
    super(name);
    // 等价于this.age = age;
    this.age = age;
  }
}
```

:::
::: tip 总结
可以观察到：

1. 类中声明的非静态方法实际上是挂载到了类的原型上
2. 类中声明的静态方法实际上是挂载到了类的构造函数上
3. 类中的属性实际上会设置到实例对象上

:::

## 类的基本使用

### 类声明和定义

类声明也有语句和表达式 class 声明体中的代码默认处于严格模式，**类声明不会提升**
::: code-group

```js [类声明]
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

```js [类定义]
const Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
```

:::

### :star:子类创建与 super 关键字

- 如果使用 extends 关键字定义了一个类，那么这个类的构造函数必须使用 super()调用父类构造函数。
- 如果没有在子类中定义构造函数，解释器会自动为你创建一个。这个隐式定义的构造函数会取得传给它的值，然后把这些值再传给 super()
- 在通过 super()调用父类构造函数之前，不能在构造函数中使用 this 关键字。这条强制规则是为了确保父类先于子类得到初始化。

### 类的私有字段设置

可以为类设置私有字段，私有字段以#开头，只能在类的内部访问，外部不能直接访问。

```js
class Person {
  // 私有字段（以#开头）
  #age = 0;

  constructor(name, age) {
    this.name = name; // 普通公共字段
    this.#age = age; // 设置私有字段
  }

  // 访问私有字段的方法
  getAge() {
    return this.#age;
  }

  // 修改私有字段的方法
  setAge(newAge) {
    if (newAge > 0) {
      this.#age = newAge;
    }
  }
}

const john = new Person('John', 30);

console.log(john.name); // "John"（公共字段可访问）
console.log(john.#age); // 报错！私有字段外部不能直接访问
console.log(john.getAge()); // 30（通过方法访问）
john.setAge(31); // 通过方法修改
```

### 类的静态代码块

ES2022+ 新特性加入了静态代码块，在类初始化的时候执行静态代码块

```js
class Person {
  static {
    console.log('类初始化');
  }
}
```
