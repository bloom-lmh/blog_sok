# 垃圾回收机制

[[toc]]

## JS 的内存生命周期

JS 环境中分配的内存，一般有如下生命周期：

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存(触发垃圾回收机制)

::: tip 底层语言的内存生命周期
对于底层语言如 c 语言，内存分配和回收都是手动进行的，而 JS 是动进行的，所以 JS 的内存管理机制是自动的。
:::

## JS 的垃圾回收机制

- 垃极回收机制(Garbage Collection)：简称 GC,是 JavaScript 内存管理系统的基本组成部分。
- 垃圾回收：JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，井且在不使用它们时自动释放。释放的过程称为垃圾回收。

::: tip 关于不再使用的理解
所谓的不再使用就是指这段内存无法再被访问到，也就是说，没有变量或对象引用它。
:::

## 内存泄漏的概念

垃圾回收器回收的垃圾是垃圾的子集，也就是说垃圾回收器回收的内存并不一定包含全部没有用的内存（因为有一部分内存它无法确定是否没有用）。如果一个值不再有用，但是垃圾回收器没有回收它，这就是内存泄漏。

1. 意外的全局变量：未声明的变量会变成 window 属性，GC 永远不会回收

```js
function foo() {
  // 未声明的变量会变成 window 属性
  bar = 'leak';
}
```

2. 遗忘的定时器 ：定时器回调保持对外部变量的引用

```js
setInterval(() => {
  /* 引用外部变量 */
}, 1000);
```

3. 闭包累积：未合理释放的闭包会持续占用内存

```js
function outer() {
  const bigData = [];
  return () => bigData.push(1);
}
```

4. DOM 游离引用 ：从 DOM 树移除的元素若被 JS 变量引用，GC 不会回收

## JS 垃圾回收机制的算法

### 引用计数法

IE 采用的引用计数算法，定义内存不再使用的标准很简单，就是看一个对象是否有指向它的引用。算法如下：

1. 跟踪记录每个值被引用的次数。
2. 如果这个值的被引用了一次，那么就记录次数 1
3. 多次引用会累加
4. 如果减少一个引用就减 1。
5. 如果引用次数是 0，则释放内存。

其缺点就是存在循环引用的问题，对于循环引用的对象内存将不会被清除。这将导致内存过大

```js
function fn() {
  let o1 = {};
  let o2 = {};
  o1.a = o2;
  o2.a = o1;
  return '引用计数无法回收';
}
// fn在执行后o1和o2的引用次数都为2，但是01和02都没有被其他变量引用，所以无法回收
fn();
```

### 标记清除法

现代的浏览器已经不再使用引用计数算法了而是使用标记清除算法。标记清除算法将不再使用的对象定义为无法达到的对象。现在大多浏览器是基于标记清除算法的某些改进算法，总体思想都是一致的。其核心如下：

1. 标记：就是从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。
2. 回收：那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
