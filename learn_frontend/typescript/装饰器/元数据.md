# 元数据

[[toc]]

## 起步

### 简介

`TypeScript` 元数据是 `TypeScript` 提供的一种在运行时访问类型信息的方式。它基于 `ECMAScript` 的装饰器提案和反射元数据 API，允许开发者在运行时获取和操作类、方法、属性等的类型信息。
::: tip 提示
简单来说就是给方法、类、属性等添加一些额外的信息，这些信息可以在运行时被获取和操作。
:::

### 环境搭建

下载：`npm install reflect-metadata --save`
配置：需要在 `tsconfig.json` 中配置以下选项

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

## 添加元数据

### 动态绑定元数据-defineMetadata

可以使用 `Reflect.defineMetadata`方法在运行时设置元数据，下面是该方法的参数：

```ts
Reflect.defineMetadata(
  key: string,
  value: any,
  target: Object,
  propertyKey: string | symbol,
  parameterIndex: number
);
```

比如为方法设置元数据：

```ts
class MyClass {
  method() {}
}

Reflect.defineMetadata('key', 'value', MyClass, 'method');
```

### 静态绑定元数据-Reflect.metadata

除了使用 defineMetadata 方法外，还可以使用 Reflect.metadata 装饰器来设置元数据,但是这样设置是静态的：

```ts
@Reflect.metadata('classMeta', 'classValue')
class MyClass {
  @Reflect.metadata('methodMeta', 'methodValue')
  public myMethod(): void {}

  @Reflect.metadata('propertyMeta', 'propertyValue')
  public myProperty: string;
}
```

可以为方法参数设置元数据：

```ts
class MyClass {
  method(@Reflect.metadata('paramMeta', 'paramValue') param: string) {}
}
```

## 获取元数据

### 获取包含原型链的元数据-getMetadata

getMetadata 方法可以获取指定类的指定方法、属性或参数上的元数据，并且它会查找原型链上的元数据：

```ts
import 'reflect-metadata';

class Parent {
  @Reflect.metadata('key', 'parent-value')
  method() {}
}

class Child extends Parent {} // 子类未定义元数据

// getMetadata 能获取父类的元数据,输出: 'parent-value' ✅（查了原型链）
console.log(Reflect.getMetadata('key', Child.prototype, 'method'));
```

### 获取自有元数据-getOwnMetadata

这个方法只能获取自有元数据无法获取原型链上的元数据：

```ts
import 'reflect-metadata';

class Parent {
  @Reflect.metadata('key', 'parent-value')
  method() {}
}

class Child extends Parent {} // 子类未定义元数据

// getOwnMetadata 获取不到（不查原型链）,输出: undefined ❌
console.log(Reflect.getOwnMetadata('key', Child.prototype, 'method'));
```

## 是否有元数据

### 检查包含原型链的元数据-hasMetadata

这个方法可以查找原型链上的元数据：

```ts
import 'reflect-metadata';

class Parent {
  @Reflect.metadata('key', 'parent-value')
  method() {}
}

class Child extends Parent {} // 子类未定义元数据

// 对比 hasMetadata（查原型链）
console.log(Reflect.hasMetadata('key', Child.prototype, 'method')); // true ✅
```

### 检查自有元数据-hasOwnMetadata

`hasOwnMetadata` 只检查对象自身是否有元数据，不检查原型链：

```ts
import 'reflect-metadata';

class Parent {
  @Reflect.metadata('key', 'parent-value')
  method() {}
}

class Child extends Parent {} // 子类未定义元数据

// 测试 hasOwnMetadata（只看自己）
console.log(Reflect.hasOwnMetadata('key', Child.prototype, 'method')); // false ❌
```

## 删除元数据

### deleteMetadata

```ts
Reflect.deleteMetadata('classMeta', MyClass);
const hasMetaNow = Reflect.hasMetadata('classMeta', MyClass);
console.log(hasMetaNow); // 输出: false
```

## 高级用法

### 获取类型参数元数据-design:xx

TypeScript 在启用 `emitDecoratorMetadata` 时，会自动为装饰器生成 ​ 设计时类型元数据，存储在 `design:type`、`design:paramtypes` 和 `design:returntype` 这三个特殊的元数据键中。这些元数据可以帮助我们在运行时获取类、方法、参数和返回值的类型信息。
| 设计类型 | 说明 | 示例 |
|------------------------|--------------------------|-------------------------------|
| `design:type` | 属性/方法/参数的类型 | `String`, `Number`, `Array` 等构造函数 |
| `design:paramtypes` | 方法参数的类型列表 | `[String, Number]` |
| `design:returntype` | 方法返回值的类型 | `Promise`, `Boolean` 等 |
::: code-group

```ts [design:type]
class Example {
  @Reflect.metadata('custom', 'value')
  name: string; // 属性类型

  @Reflect.metadata('custom', 'value')
  greet(): string {
    return 'Hello';
  } // 方法返回类型
}

// 获取属性类型
const propType = Reflect.getMetadata('design:type', Example.prototype, 'name');
console.log(propType); // [Function: String] ✅

// 获取方法返回类型
const returnType = Reflect.getMetadata('design:type', Example.prototype, 'greet');
console.log(returnType); // [Function: Function]（方法本身是 Function 类型）
```

```ts [design:paramtypes]
class ApiService {
  getUser(
    @Reflect.metadata('param:desc', 'ID') id: string,
    @Reflect.metadata('param:desc', 'Page') page: number,
  ): Promise<User> {
    return Promise.resolve({ id, name: 'Alice' });
  }
}

// 获取参数类型列表
const paramTypes = Reflect.getMetadata('design:paramtypes', ApiService.prototype, 'getUser');
console.log(paramTypes); // [ [Function: String], [Function: Number] ] ✅
```

```ts [design:returntype]
const returnType = Reflect.getMetadata('design:returntype', ApiService.prototype, 'getUser');
console.log(returnType); // [Function: Promise] ✅
```

:::
