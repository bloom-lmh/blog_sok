# 条件类型

[[toc]]

## 什么是条件类型？

### 基本使用

extends 用于判断一个类型是否满足另一个类型，并返回不同的结果。
基本语法：

```typescript
T extends U ? X : Y
```

如果 T 可以赋值给 U，则返回 X，否则返回 Y。
::: tip 什么是可赋值
后面类型兼容性机制会讲到。如果一个类型的子结构与另一类型结构相同，那么这两个类型就是相兼容的，结构复杂的可以赋值给结构简单的
:::

### 分布式条件类型

### 分布式条件类型（类型层面的 Map）

分布式条件类型 是指：当一个条件类型作用于联合类型时，TypeScript 会自动将该条件类型“分发”到联合类型的每一个成员上，并最终合并结果。

```ts
type ToArray<T> = T extends any ? T[] : never;
type Result = ToArray<string | number>;
// 结果是 string[] | number[]
```

::: warning 什么时候不分布
只有满足以下形式才会自动分布：

```ts
T extends U ? X : Y
```

- T 是裸类型参数（即直接是泛型参数，没有被包裹）
- 出现在 extends 左边

而下面 T 被包裹，所以不会自动分布：

```ts
type ToArray<T> = [T] extends [any] ? T[] : never;

type Result = ToArray<string | number>;
// 结果是：(string | number)[]
```

:::

## 例子

### 类型过滤

```ts
type FilterNumbers<T> = T extends number ? T : never;

type Mixed = string | number | boolean;
type OnlyNumbers = FilterNumbers<Mixed>; // number
```

### 实现 Exclude 和 Extract

```ts
type MyExclude<T, U> = T extends U ? never : T;
type MyExtract<T, U> = T extends U ? T : never;

type T = 'a' | 'b' | 'c';
type Excluded = MyExclude<T, 'a'>; // 'b' | 'c'
type Extracted = MyExtract<T, 'a' | 'c'>; // 'a' | 'c'
```

解释：MyExclude

- 如果 T 可以赋值给 U，则返回 never（表示排除）。
- 否则，保留 T。

解释：MyExtract

- 如果 T 可以赋值给 U，则返回 T。
- 否则，返回 never（表示不包含）。

### 分布式条件类型运用

比如我要获取某个对象中的所有属性类型的提示就可以使用分布式条件类型。

```ts
// 手动定义模块类型（因为 faker 没有暴露模块的联合类型）
type FakerModule = keyof Faker; // 'animal', 'book', 'person', ...
// 构建完整的路径：module.method
type FakerMethodPath<M extends FakerModule> = M extends M
  ? keyof Faker[M] extends string
    ? `${M}.${keyof Faker[M]}`
    : never
  : never;
```
