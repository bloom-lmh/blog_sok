# 浏览器渲染流程

参考文献
[1](https://zhuanlan.zhihu.com/p/586060532)
[2](https://juejin.cn/post/7407832512456933417)
[[toc]]

## 解析 HTML

一旦浏览器收到第一个数据分块，它就可以开始解析收到的信息。“解析”是浏览器将通过网络接收的数据转换为  DOM  和  CSSOM  的步骤，通过渲染器在屏幕上将它们绘制成页面。
虽然 DOM 是浏览器标记的内部表示，但是它也被暴露出来，可以通过 JavaScript 中的各种 API 进行操作。

### 构建 DOM 树

第一步是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到符号化（词法分析）和树的构造。HTML 标记包括开始和结束标记，以及属性名和值。如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建 DOM 树。
树结构类似于现实生活中的“树”，每个点称为节点，相连的节点称为父子节点。DOM 树构建过程示意图：
![解析HTML构建DOM树](https://s3.bmp.ovh/imgs/2025/05/11/58972f70eb318c1f.png)
构建 DOM 树的输入内容是一个 HTML 文件，然后经过 HTML 解析器解析，最终输出树状结构的 DOM。 通过【开发者工具】 ⇒ 【控制台】，输入 document 回车后可查看完整的 DOM 树结构。
![浏览器中查看DOM树](https://s3.bmp.ovh/imgs/2025/05/11/3cffe50c809fc877.png)

### 子资源加载

当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于  `<script>`标签（特别是没有  async 或者  defer  属性的）会阻塞渲染并停止 `HTML` 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。

:::tip 预加载扫描器

浏览器构建 DOM 树时，这个过程占用了主线程。同时，预加载扫描器会解析可用的内容并请求高优先级的资源，如 CSS、JavaScript 和 web 字体。多亏了预加载扫描器，我们不必等到解析器找到对外部资源的引用时才去请求。它将在后台检索资源，而当主 HTML 解析器解析到要请求的资源时，它们可能已经下载中了，或者已经被下载。预加载扫描器提供的优化减少了阻塞。
:::
预加载扫描器示意图：
![预加载扫描器](https://s3.bmp.ovh/imgs/2025/05/11/dd8acb573fff147e.png)

## 构建 CSSOM 树

HTML 加载 CSS 的三种方式：
![加载 CSS 的三种方式](https://s3.bmp.ovh/imgs/2025/05/11/20510156b8aabdb7.webp)

### 解析 CSS 文件

由于浏览器也无法解析纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时， 会将 CSS 文本转换为浏览器可以理解的结构 StyleSheets，也就是 CSSOM ，并提供了查询和修改功能。
通过控制台 document.styleSheets 可查看结构：
![解析 CSS 文件](https://s3.bmp.ovh/imgs/2025/05/11/5026efcecb848fa5.webp)
构建 CSSOM 非常快，并且在当前的开发工具中没有以独特的颜色显示。相反，开发人员工具中的“重新计算样式”显示解析 CSS、构建 CSSOM 树和递归计算计算样式所需的总时间。在 web 性能优化方面，它是可轻易实现的，因为创建 CSSOM 的总时间通常小于一次 DNS 查询所需的时间。

## 样式计算

拥有 DOM 并不足以知道页面的显示效果，因为我们可以在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点的计算样式。这是关于根据 CSS 选择器将哪种样式应用于每个元素的信息。您可以在开发者工具的  computed  部分查看此信息。
![样式计算](https://s3.bmp.ovh/imgs/2025/05/11/43164a9f5db97cb4.png)

### CSS 继承与层叠

浏览器会根据 CSS 规则计算每个元素的样式属性值，包括继承自父元素的属性值和层叠样式表（如用户代理样式表、作者样式表和用户样式表）的属性值。

#### CSS 继承

CSS 继承就是每个 DOM 节点都包含了父节点的样式。例如：

```css
body {
  font-size: 20px;
}
p {
  color: blue;
}
span {
  display: none;
}
div {
  font-weight: bold;
  color: red;
}
div p {
  color: green;
}
```

可了解到，例如 body 节点的 font-size 的属性，body 节点下的所以子节点都继承了。

另可通过“开发者工具”->Element，查看“style”标签：
![CSS 继承](https://s3.bmp.ovh/imgs/2025/05/11/a7f7b28c02e82c69.webp)
通过分析，我们可以选择对应第一区域对应的元素，可查询该元素的样式（对应区域 2 中）； 并且可通过区域 3 可查看对应样式的来源详情，其中，UserAgent 样式，是浏览器提供的一组默认样式，如果不修改任何样式，默认使用的是 UserAgent 样式。

#### CSS 层叠

层叠是 CSS 的一个基本特征，它定义了如何合并来自多个源的属性值的算法。 CSS 的全称“层叠样式表”即强调了这点。

可通过“开发者工具” ⇒ Element 标签，“Computed”查看最后的计算样式：

### 标准化样式表中的属性值

CSS 文本中存在很多属性值，例如 1em、blue、bold 等属性值不容易被渲染引擎识别，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个 过程就是属性值标准化。
标准化属性值：
![标准化样式表中的属性值](https://s3.bmp.ovh/imgs/2025/05/11/eea3b38a7680fba7.png)
CSS 文本中的很多属性值，如 2em、blue、bold 不容易渲染引擎理解，因此需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。
我们看到，经过属性值标准化后，2em 被解析成 32px，blue 被解析成 rgb(0, 0, 255)，bold 被解析成 700。

### 构建渲染树（Render Tree）

浏览器会根据 DOM 树和计算好的样式属性值构建渲染树（也称为布局树或框模型树）。渲染树是 DOM 树的一个副本，但它只包含可见元素，并且每个元素都有一个对应的盒模型（包括宽度、高度、边距、边框等）。
![构建渲染树](https://s3.bmp.ovh/imgs/2025/05/11/1175b81a009cf56b.png)

## 布局（回流）

现在，渲染程序进程知道文档的结构以及每个节点的样式，但这不足以渲染页面。假设你正尝试通过电话向朋友描述一幅画。“有一个大的红色圆圈和一个小的蓝色方块”是不够的信息，不足以让你的朋友知道这幅画究竟是什么样子。
布局是在渲染树上运行布局以计算每个节点的几何体。
Chrome 在布局阶段需完成两个任务：布局 和 重排。

1. 布局 是首次确定渲染树中所有节点的尺寸和位置，以及确定页面上每个对象的大小和位置的过程。
2. 重排 是后续过程中对页面的任意部分或整个文档的大小和位置的重新计算。

### 布局 Layout（创建布局树）

![布局 Layout（创建布局树）](https://s3.bmp.ovh/imgs/2025/05/11/5832845596402beb.png)
其中 DOM 树中还包含很多不可见的元素，例如 head 标签，display: none 属性的元素等。所以在显示之前，需要额外构建一颗只包含可见元素的布局树。
为了构建布局树，浏览器需要：

- 遍历 DOM 树：浏览器从 DOM 树的根节点开始，遍历整个树，找到所有可见元素。
- 过滤不可见元素：浏览器过滤掉不可见元素，如  display: none  的元素、visibility: hidden  的元素等。
- 创建布局树节点：浏览器为每个可见元素创建一个布局树节点，这个节点包含了元素的基本信息，如元素的 ID、类名、样式等。
- 建立父子关系：浏览器建立布局树节点之间的父子关系，确保每个元素的布局信息与其父元素和子元素的布局信息保持一致。

在创建完整的布局树后，需要计算布局树中节点的准确位置。

### 布局计算（重排 Reflow）

布局计算是确定元素几何形状的过程。
HTML 采用流式布局模型，其基本原则是按照元素在文档流中的顺序，自左向右、自上而下排列。此外，还有一些特殊布局方式，如通过 position 属性进行定位布局和通过 float 实现的浮动布局。
主线程会遍历 DOM 树和计算出的样式，创建布局树，其中包含元素的坐标（x 和 y）及边界框大小等信息。虽然布局树的结构可能与 DOM 树类似，但它仅包含与页面上可见内容相关的元素。如果某个元素应用了 display: none ，它将不会出现在布局树中（不过，visibility: hidden 的元素仍会存在于布局树中）。同样，伪元素（例如 p::before { content: "Hi!" }）会包含在布局树中，即使它们不在 DOM 中。
布局是一项复杂的任务，即使是最简单的页面布局（如从上到下的块级流）也需要考虑字体大小和换行位置，因为这些会影响段落的大小和形状，并进而影响下一个段落的位置。

CSS 可以使元素悬浮、裁剪溢出内容以及更改书写方向，因此布局阶段非常繁重。

### 布局树和渲染树的关系

布局树（Layout Tree）和渲染树（Render Tree）是浏览器渲染页面的两个重要数据结构，它们之间有着密切的关系。
以下是布局树和渲染树的关系图：

```lua
DOM树
  |
  |-- 布局树（Layout Tree）
  |    |
  |    |-- 元素的布局信息（位置、大小等）
  |
  |-- 渲染树（Render Tree）
       |
       |-- 元素的渲染信息（样式、颜色、字体等）
       |-- 渲染器（Renderer）
```

## 分层

拥有 DOM、样式和布局仍然不足以渲染页面。假设你正尝试复制一幅画。你已经知道元素的大小、形状和位置，但仍需判断它们的绘制顺序。

例如，系统可能会为某些元素设置 z-index，在这种情况下，按 HTML 中编写的元素的顺序进行绘制会导致呈现错误。
在此绘制步骤中，主线程会遍历布局树来创建绘制记录。绘制记录是绘制过程的备注，例如“先提供背景，然后是文本，最后是矩形”。如果你使用 JavaScript 在 `<canvas>` 元素上绘制了内容，那么你可能已经熟悉此过程。

### 创建绘制记录

在这个阶段，浏览器通过遍历布局树来生成一个具有绘制顺序的绘制记录。这一过程类似于在绘画过程中记录每个绘制动作的顺序，确保图像按正确的顺序显示。
绘制记录的组成：

- 背景： 首先绘制元素的背景。
- 内容： 然后绘制内容，例如文本、图像等。
- 边框： 最后绘制边框或阴影。

这些步骤确保了视觉效果的层次正确。浏览器生成的绘制记录包含绘制每个元素及其内容的详细指令。

```js
[
  {type: "background", rect: {...}, color: "#fff"},
  {type: "text", position: {...}, text: "Hello World"},
  {type: "border", rect: {...}, style: "solid"}
]

```

### 构建分层树（Layer Tree）

为了确定哪些元素需要位于哪些层，主线程会遍历布局树来创建分层树。浏览器的页面实际上被分层了很多图层，这些图层叠加后合成最终的页面。
布局树中的每个元素不一定都对应一个分层。层是为了优化重绘性能和处理复杂的层叠上下文而引入的。
图层树允许浏览器将页面内容分解为更小、可管理的单位，以提高渲染性能和减少重绘的开销。
通常情况下，并不是**布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。

## 总结

我们了解到了渲染流程的前三个阶段为：DOM 生成、样式计算和布局：

浏览器不能直接解析 HTML 数据，所以第一步需要将其转换为 DOM 树结构；
生成 DOM 树后，接着根据 CSS 样式表，计算 DOM 树所以节点的样式；
最后根据计算 DOM 元素的布局信息，保存在布局树中。
